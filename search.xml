<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>BIO、NIO和AIO的区别及用法</title>
    <url>/2021/06/01/BIO%E3%80%81NIO%E5%92%8CAIO%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%81%E4%B8%89%E7%A7%8DIO%E7%9A%84%E7%94%A8%E6%B3%95%E4%B8%8E%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="BIO、NIO和AIO的区别、三种IO的用法与原理"><a href="#BIO、NIO和AIO的区别、三种IO的用法与原理" class="headerlink" title="BIO、NIO和AIO的区别、三种IO的用法与原理"></a>BIO、NIO和AIO的区别、三种IO的用法与原理</h1><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><p>什么是IO？它是指计算机与外部世界或者一个程序与计算机的其余部分之间的接口。它对于任何计算机系统都非常关键，因而所有I/O的主体实际上内置在操作系统中的。单独的程序一般都是让系统为他们完成大部分的工作。</p>
<h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><p>Java BIO 即 Block I/O，同步并阻塞的IO。</p>
<p>BIO就是传统的java.io报包下面的代码实现。</p>
<a id="more"></a>

<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>什么是<code>NIO</code>？NIO与原来的<code>I/O</code>有同样的作用和目的，他们之前最重要的区别是数据打包和传输的方式。原来的<code>I/O</code>以流的方式处理数据，而 <code>NIO</code> 以快的方式处理数据。</p>
<p>而向流的<code>I/O</code>系统一次一个字节的处理数据。一个输入流产生一个字节的数据，一个输出流消费一个字节的数据。为流式数据创建过滤器非常容易。链接几个过滤器，以便每个过滤器只负责单个复杂处理机制的一部分，这样也是相对简单的。不利的一面是，面向流的<code>I/O</code>通常非常慢。</p>
<p>一个面向块的<code>I/O</code>系统以块的形式处理器。每一个操作都在一步中产生或者消费一个数据库。按块处理数据比按(流式的)字节处理数据要快得多。但是面向块的<code>I/O</code>缺少一些面向流的<code>I/O</code>所具有的优雅型和简单性。</p>
<h2 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h2><p>Java AIO即 Async 非阻塞，是异步非阻塞的IO。</p>
<h2 id="区别及联系"><a href="#区别及联系" class="headerlink" title="区别及联系"></a>区别及联系</h2><p>BIO (Blocking I/O)：同步阻塞<code>I/O</code>模式，数据的读取写入必须阻塞在一个线程内等待其完成。这里假设一个烧开水的场景。有一排水壶在烧开水，<code>BIO</code> 的工作模式就是，叫一个线程停留在一个水壶那，直到这个水壶烧开，才去处理下一个水壶。但是实际上线程在等待水壶烧开的时间段什么都没有做。</p>
<p>NIO （New I/O）：同时支持阻塞与非阻塞模式，但这里我们以其同步非阻塞<code>I/O</code>模式来说明，那么什么叫做同步非阻塞？如果还拿烧开水来说，<code>NIO</code>的做法是叫一个线程不断地轮询每个水壶的状态，看看是否有水壶的状态发生了改变，从而进行下一步的操作。</p>
<p>AIO （ Asynchronous I/O）：异步非阻塞<code>I/O</code>模型。异步非阻塞与同步非阻塞的区别在哪里？异步非阻塞无需一个线程去轮询所有<code>IO</code>操作的状态改变，在相应的状态改变后，系统会通知对应的线程来处理。对应到烧开水中就是，为每个水壶上面装了一个开关，水烧开之后，水壶会自动通知我水烧开了。</p>
<h2 id="各自使用场景"><a href="#各自使用场景" class="headerlink" title="各自使用场景"></a>各自使用场景</h2><p>BIO方式适用于连接数目比较小且固定的架构，这种方式对服务器资源要求比较高，并发局限于应用中，JDK1.4以前的唯一选择，但程序直观简单易理解。</p>
<p>NIO方式适用于连接数目多且连接比较短（轻操作）的架构，比如聊天服务器，并发局限于应用中，编程比较复杂，JDK1.4开始支持。</p>
<p>AIO方式适用于连接数目多且连接比较长（重操作）的架构，比如相册服务器，充分调用OS参与并发操作，编程比较复杂，JDK7开始支持。</p>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><h3 id="使用-BIO-实现文件的读取和写入"><a href="#使用-BIO-实现文件的读取和写入" class="headerlink" title="使用 BIO 实现文件的读取和写入"></a>使用 BIO 实现文件的读取和写入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//Initializes The Object</span></span><br><span class="line"> User1 user = <span class="keyword">new</span> User1();</span><br><span class="line"> user.setName(<span class="string">&quot;hollis&quot;</span>);</span><br><span class="line"> user.setAge(<span class="number">23</span>);</span><br><span class="line"> System.out.println(user);</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Write Obj to File</span></span><br><span class="line"> ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;tempFile&quot;</span>));</span><br><span class="line">     oos.writeObject(user);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line"> &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     IOUtils.closeQuietly(oos);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Read Obj from File</span></span><br><span class="line"> File file = <span class="keyword">new</span> File(<span class="string">&quot;tempFile&quot;</span>);</span><br><span class="line"> ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line"> <span class="keyword">try</span> &#123;</span><br><span class="line">     ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">     User1 newUser = (User1) ois.readObject();</span><br><span class="line">     System.out.println(newUser);</span><br><span class="line"> &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line"> &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">     e.printStackTrace();</span><br><span class="line"> &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     IOUtils.closeQuietly(ois);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         FileUtils.forceDelete(file);</span><br><span class="line">     &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="使用-NIO-实现文件的读取和写入"><a href="#使用-NIO-实现文件的读取和写入" class="headerlink" title="使用 NIO 实现文件的读取和写入"></a>使用 NIO 实现文件的读取和写入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readNIO</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String pathname = <span class="string">&quot;C:\\Users\\adew\\Desktop\\jd-gui.cfg&quot;</span>;</span><br><span class="line">        FileInputStream fin = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fin = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(pathname));</span><br><span class="line">            FileChannel channel = fin.getChannel();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> capacity = <span class="number">100</span>;<span class="comment">// 字节</span></span><br><span class="line">            ByteBuffer bf = ByteBuffer.allocate(capacity);</span><br><span class="line">            System.out.println(<span class="string">&quot;限制是：&quot;</span> + bf.limit() + <span class="string">&quot;容量是：&quot;</span> + bf.capacity()</span><br><span class="line">                    + <span class="string">&quot;位置是：&quot;</span> + bf.position());</span><br><span class="line">            <span class="keyword">int</span> length = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((length = channel.read(bf)) != -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 注意，读取后，将位置置为0，将limit置为容量, 以备下次读入到字节缓冲中，从0开始存储</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                bf.clear();</span><br><span class="line">                <span class="keyword">byte</span>[] bytes = bf.array();</span><br><span class="line">                System.out.write(bytes, <span class="number">0</span>, length);</span><br><span class="line">                System.out.println();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">&quot;限制是：&quot;</span> + bf.limit() + <span class="string">&quot;容量是：&quot;</span> + bf.capacity()</span><br><span class="line">                        + <span class="string">&quot;位置是：&quot;</span> + bf.position());</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            channel.close();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fin != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fin.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeNIO</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String filename = <span class="string">&quot;out.txt&quot;</span>;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(filename));</span><br><span class="line">            FileChannel channel = fos.getChannel();</span><br><span class="line">            ByteBuffer src = Charset.forName(<span class="string">&quot;utf8&quot;</span>).encode(<span class="string">&quot;你好你好你好你好你好&quot;</span>);</span><br><span class="line">            <span class="comment">// 字节缓冲的容量和limit会随着数据长度变化，不是固定不变的</span></span><br><span class="line">            System.out.println(<span class="string">&quot;初始化容量和limit：&quot;</span> + src.capacity() + <span class="string">&quot;,&quot;</span></span><br><span class="line">                    + src.limit());</span><br><span class="line">            <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> ((length = channel.write(src)) != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 注意，这里不需要clear，将缓冲中的数据写入到通道中后 第二次接着上一次的顺序往下读</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                System.out.println(<span class="string">&quot;写入长度:&quot;</span> + length);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (fos != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    fos.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="使用AIO实现文件的读取和写入"><a href="#使用AIO实现文件的读取和写入" class="headerlink" title="使用AIO实现文件的读取和写入"></a>使用AIO实现文件的读取和写入</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadFromFile</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Path file = Paths.get(<span class="string">&quot;/usr/a.txt&quot;</span>);</span><br><span class="line">    AsynchronousFileChannel channel = AsynchronousFileChannel.open(file);</span><br><span class="line"></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">100_000</span>);</span><br><span class="line">    Future&lt;Integer&gt; result = channel.read(buffer, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!result.isDone()) &#123;</span><br><span class="line">      ProfitCalculator.calculateTax();</span><br><span class="line">    &#125;</span><br><span class="line">    Integer bytesRead = result.get();</span><br><span class="line">    System.out.println(<span class="string">&quot;Bytes read [&quot;</span> + bytesRead + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProfitCalculator</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ProfitCalculator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">calculateTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteToFile</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    AsynchronousFileChannel fileChannel = AsynchronousFileChannel.open(</span><br><span class="line">        Paths.get(<span class="string">&quot;/asynchronous.txt&quot;</span>), StandardOpenOption.READ,</span><br><span class="line">        StandardOpenOption.WRITE, StandardOpenOption.CREATE);</span><br><span class="line">    CompletionHandler&lt;Integer, Object&gt; handler = <span class="keyword">new</span> CompletionHandler&lt;Integer, Object&gt;() &#123;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, Object attachment)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Attachment: &quot;</span> + attachment + <span class="string">&quot; &quot;</span> + result</span><br><span class="line">            + <span class="string">&quot; bytes written&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;CompletionHandler Thread ID: &quot;</span></span><br><span class="line">            + Thread.currentThread().getId());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable e, Object attachment)</span> </span>&#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Attachment: &quot;</span> + attachment + <span class="string">&quot; failed with:&quot;</span>);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Main Thread ID: &quot;</span> + Thread.currentThread().getId());</span><br><span class="line">    fileChannel.write(ByteBuffer.wrap(<span class="string">&quot;Sample&quot;</span>.getBytes()), <span class="number">0</span>, <span class="string">&quot;First Write&quot;</span>,</span><br><span class="line">        handler);</span><br><span class="line">    fileChannel.write(ByteBuffer.wrap(<span class="string">&quot;Box&quot;</span>.getBytes()), <span class="number">0</span>, <span class="string">&quot;Second Write&quot;</span>,</span><br><span class="line">        handler);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>I/O</category>
      </categories>
      <tags>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title>ELK日志收集</title>
    <url>/2021/06/20/ELK%E6%97%A5%E5%BF%97%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<h2 id="ELK-日志收集平台"><a href="#ELK-日志收集平台" class="headerlink" title="ELK 日志收集平台"></a>ELK 日志收集平台</h2><p>很早之前就听过 ELK 日志收集，但是一直都没有具体的业务场景，也没有多余的时间去接触这个，这两天空了，学习下。</p>
<p>关于 ELK，自己之前的认知，就是一个可以收集各个服务器的日志信息，并进行统一的分析处理的平台。</p>
<p>学习的时候发现，有一篇文章关于 ELK 平台的认知讲的很好，就摘抄一小段：</p>
<p>以下内容来自于以下网站：</p>
<blockquote>
<p><a href="https://blog.51cto.com/baidu/1676798">https://blog.51cto.com/baidu/1676798</a></p>
</blockquote>
<p>日志主要包括系统日志、应用程序日志和安全日志。系统运维和开发人员可以通过日志了解服务器软硬件信息、检查配置过程中的错误及错误发生的原因。经常分析日志可以了解服务器的负荷，性能安全性，从而及时采取措施纠正错误。</p>
<p>通常，日志被分散的储存不同的设备上。如果你管理数十上百台服务器，你还在使用依次登录每台机器的传统方法查阅日志。这样是不是感觉很繁琐和效率低下。当务之急我们使用集中化的日志管理，例如：开源的 syslog ，将所有服务器上的日志收集汇总。</p>
<p>集中化管理日志后，日志的统计和检索又成为一件比较麻烦的事情，一般我们使用 grep、awk 和 wc 等 Linux 命令能实现检索和统计，但是对于要求更高的查询、排序和统计等要求和庞大的机器数量依然使用这样的方法难免有点力不从心。</p>
<p>开源实时日志分析 ELK 平台能够完美的解决我们上述的问题，ELK 由 ==ElasticSearch==、==Logstash== 和 ==Kiabana== 三个开源工具组成。官方网站：<a href="https://www.elastic.co/products%E3%80%82%E7%8E%B0%E5%9C%A8%E5%B8%B8%E7%94%A8%E7%9A%84">https://www.elastic.co/products。现在常用的</a> ELK 平台由以下部分组成：</p>
<ul>
<li><p>Elasticsearch 是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful 风格接口，多数据源，自动搜索负载等。</p>
</li>
<li><p>Logstash 是一个完全开源的工具，他可以对你的日志进行收集、分析，并将其存储供以后使用（如，搜索）。(由于 Logstash 性能不够达标，所以采用 elastic 官方发布了新的收集工具 ： beats-轻量级采集组件，在服务器上使用它进行日志采集)。</p>
</li>
<li><p>kibana 也是一个开源和免费的工具，Kibana 可以为  Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助您汇总、分析和搜索重要数据日志。</p>
</li>
<li><p>beats : 轻量级采集组件的统称，官方及社区的活跃成员，共发布了几百种不同的 beats。常见的 beats 有如下几种：</p>
<ul>
<li>filebeat: 进行<code>文件和目录</code>采集，主要用于收集日志数据。</li>
<li>metricbeat: 进行<code>指标</code>采集，指标可以是系统的，也可以是众多中间件产品的，主要用于监控<code>系统和软件</code>的性能。</li>
<li>packetbeat: 通过网络抓包、协议分析，对一些请求响应式的<code>系统通信</code>进行监控和数据收集，可以收集到很多常规方式无法收集到的信息。</li>
<li>Winlogbeat: 专门针对 windows 的 <code>event log</code> 进行的数据采集。</li>
<li>Heartbeat: <code>系统间连通性</code>检测，比如 icmp, tcp, http 等系统的连通性监控。</li>
</ul>
</li>
<li><p>kafka : 常见的消息中间件，减轻服务器消息收集过后的压力。</p>
</li>
</ul>
<p>ELK 整体运行的组件如下图所示：</p>
<p>![ELK 日志](./ELK日志收集/ELK 日志.png)</p>
<p>具体的运行逻辑：</p>
<p>Beats 组件从应用服务器上收集到对应的日志信息，发送到 Kafka 中，然后通过 Logstash，进行统一的收集处理，然后存储在 ElasticSearch 中，最后通过可视化工具 Kibana 进行查看。</p>
<h4 id="安装、运行、操作逻辑如下："><a href="#安装、运行、操作逻辑如下：" class="headerlink" title="安装、运行、操作逻辑如下："></a>安装、运行、操作逻辑如下：</h4>]]></content>
      <tags>
        <tag>ELK日志</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap的问题</title>
    <url>/2021/07/13/HashMap%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="谈谈-HashMap-吧"><a href="#谈谈-HashMap-吧" class="headerlink" title="谈谈 HashMap 吧"></a>谈谈 HashMap 吧</h2><blockquote>
<p>很多的时候，你在面试的时候，很多面试官，在问到 java 集合的时候，都会问到 HashMap 这么一个神奇的结构，现在就来记录下关于 HashMap 的学习和理解</p>
</blockquote>
<p>HashMap 是 Java 中为数不多的支持 key-value 结构的集合。很多的时候都用来组装返回前端的数据结构，更多的时候，我们都不会过多关注与其底层设计，但其实，深入查看了 HashMap 的代码，你会发现，写 Java 都是些什么怪物哦，就很妙。</p>
<p>HashMap的底层结构，是由 “数组 + 链表 / <code>红黑树</code>” 的结构实现的。</p>
<blockquote>
<p>在 jdk1.7 之前，都是使用的此结构。</p>
<p>到了 jdk1.8 的时候，对此结构进行了小小的改变：</p>
<ul>
<li><p>当链表的长度超过 8 的时候，就会转换链表为 <code>红黑树</code> 。</p>
</li>
<li><p>如果小于 8 的时候，又会转换为 <code>链表</code></p>
</li>
</ul>
</blockquote>
<a id="more"></a>

<p>对应的源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 数组结构 </span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 链表结构</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">  <span class="keyword">final</span> K key;</span><br><span class="line">  V value;</span><br><span class="line">  Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">  Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hash = hash;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.next = next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">&quot;=&quot;</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">    V oldValue = value;</span><br><span class="line">    value = newValue;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">      Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">      <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">          Objects.equals(value, e.getValue()))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 红黑树结构</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="keyword">boolean</span> red;</span><br><span class="line">  ....</span><br><span class="line">    </span><br><span class="line">    </span><br></pre></td></tr></table></figure>


<p>具体结构图如下：</p>
<p><img src="/2021/07/13/HashMap%E7%9A%84%E9%97%AE%E9%A2%98/Hashmap.png" alt="Hashmap"></p>
<p>常见问题：</p>
<ul>
<li><h3 id="table-的初始化时什么时候？初始化的-length-是多少？临界点是多少？实际上能够存储多少元素？"><a href="#table-的初始化时什么时候？初始化的-length-是多少？临界点是多少？实际上能够存储多少元素？" class="headerlink" title="table 的初始化时什么时候？初始化的 length 是多少？临界点是多少？实际上能够存储多少元素？"></a>table 的初始化时什么时候？初始化的 length 是多少？临界点是多少？实际上能够存储多少元素？</h3><p>HashMap 的初始化一共分为以下 4 种：</p>
<ul>
<li><p>第一种 : 指定 <code>初始化大小</code> initialCapacity 和 <code>加载因子</code> loadFactor ，实例化一个空的对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                                       initialCapacity);</span><br><span class="line">  <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">    initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">  <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                                       loadFactor);</span><br><span class="line">  <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">  <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>第二种 :  通过指定的初始化大小 和 默认的加载因子( 0.75) 实例化一个空的 HashMap 对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">常见的处理就是这种 :  Map&lt;String,String&gt; map = new HashMap(16);这个也是阿里巴巴开发手册推荐的实例化方法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>第三种 : 使用默认的 <code>初始化大小</code> : 16 和 默认的 <code>加载因子</code>: 0.75</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>第四种 : 通过指定的 Map 对象，来实例化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">  putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这四种方法，方法4 和方法 1应用的很少，主要的都是2，3两种方式，构造方式2，直接调用的第一种的1 (底层方式完全一致)。主要以案例2来进行描述</p>
</li>
</ul>
<p>我们平时基本都是按照如下代码来使用 HashMap 的 : </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">16</span>);</span><br><span class="line">map.put(<span class="string">&quot;name&quot;</span>:<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">map.put(<span class="string">&quot;age&quot;</span>:<span class="number">15</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>在这个时候， table 并未初始化，那么 new 的时候，没有被初始化，那只可能是在 put 的时候被初始化了，看下源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">  <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">		<span class="comment">// 这里首先的进入了 resize 方法。</span></span><br><span class="line">    n = (tab = resize()).length;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">  Node&lt;K,V&gt;[] oldTab = table; <span class="comment">// 第一次赋值，为 null</span></span><br><span class="line">  <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length; <span class="comment">// oldTab = 0</span></span><br><span class="line">  <span class="keyword">int</span> oldThr = threshold; <span class="comment">// threshold = 0, oldTab = 0</span></span><br><span class="line">  <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123; <span class="comment">// 不满足</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">      threshold = Integer.MAX_VALUE;</span><br><span class="line">      <span class="keyword">return</span> oldTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">      newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 不满足 initial capacity was placed in threshold</span></span><br><span class="line">    newCap = oldThr;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 满足条件了</span></span><br><span class="line">    <span class="comment">// zero initial threshold signifies using defaults </span></span><br><span class="line">    newCap = DEFAULT_INITIAL_CAPACITY;  <span class="comment">// 初始化大小为默认的 DEFAULT_INITIAL_CAPACITY = 1 &gt;&gt; 4 = 16</span></span><br><span class="line">    newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); <span class="comment">// 临界点为 : 16 * 0.75 = 12;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">              (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">  threshold = newThr;	<span class="comment">// 边界值为 12，即超过 12 ，就要执行 resize方法进行扩容</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">  Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap]; <span class="comment">// 初始化为 16</span></span><br><span class="line">  table = newTab;	<span class="comment">// 此时，table 初始化完成，长度为 16</span></span><br><span class="line">  <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123; <span class="comment">// 条件不满足，后续扩容的时候，走这个 if 分支，将数组元素复制到新的数组中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">      Node&lt;K,V&gt; e;</span><br><span class="line">      <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">          newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">          ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">          Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; next;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">            next = e.next;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">              loTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">              hiTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">          <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">            newTab[j] = loHead;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">            newTab[j + oldCap] = hiHead;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 返回一个新的数组</span></span><br><span class="line">  <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>从上面的代码可以看到，HashMap初始化的时候，并不会初始化 table 数组，只有当 第一次 put 方法触发的时候，才会对 table 数组进行初始化(这也就是常见的懒加载、懒初始化的思想)。</p>
<p>默认情况下：即不手动指定</p>
<ul>
<li>数组的长度为 16，table.length = 16;</li>
<li>临界值 : threshold = 12; </li>
<li>默认能够存放 12 个元素，当到达 13 个元素的时候，触发扩容</li>
</ul>
</li>
<li><h4 id="什么时候会触发-HashMap-的扩容？扩容过后大小、临界值各是多少？"><a href="#什么时候会触发-HashMap-的扩容？扩容过后大小、临界值各是多少？" class="headerlink" title="什么时候会触发 HashMap 的扩容？扩容过后大小、临界值各是多少？"></a>什么时候会触发 HashMap 的扩容？扩容过后大小、临界值各是多少？</h4><p>从问题能够理解，当一个集合大小不够的时候，我们是可以动态扩容的，HashMap大小不够，只能是扩容 table ，那么只有 put 方法能够触发这个事件，所以，我们先查看下 put() 的源码 : </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">  <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    n = (tab = resize()).length;</span><br><span class="line">  <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    Node&lt;K,V&gt; e; K k;</span><br><span class="line">    <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">        ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">      e = p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">      e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">          p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">          <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">            treeifyBin(tab, hash);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        p = e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">      V oldValue = e.value;</span><br><span class="line">      <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">        e.value = value;</span><br><span class="line">      afterNodeAccess(e);</span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ++modCount;</span><br><span class="line">  <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">    <span class="comment">// 当前 table 的大小 大于 临界值的时候，调用 resize 方法进行扩容</span></span><br><span class="line">    resize();</span><br><span class="line">  afterNodeInsertion(evict);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码可以知道，当 table 的大小 ==大于== 临界值的时候，进行扩容，接下来看扩容代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">  Node&lt;K,V&gt;[] oldTab = table; <span class="comment">// 获取当前的 table,当前 table 不为空</span></span><br><span class="line">  <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length; <span class="comment">// oldCap = 16，第一次初始化的时候为16</span></span><br><span class="line">  <span class="keyword">int</span> oldThr = threshold;	<span class="comment">// oldThr = 12,oldCap = 16;</span></span><br><span class="line">  <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 满足条件进入当前 if 判断</span></span><br><span class="line">  <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">      threshold = Integer.MAX_VALUE;</span><br><span class="line">      <span class="keyword">return</span> oldTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">      <span class="comment">// 满足条件，oldCap 左移一位，16 &lt;&lt; 1 = 32;</span></span><br><span class="line">      <span class="comment">// 同时让当前的 边界大小 &lt;&lt; 1 = 24;</span></span><br><span class="line">      newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">    newCap = oldThr;</span><br><span class="line">  <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">              (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当前临界值为 24</span></span><br><span class="line">  threshold = newThr;</span><br><span class="line">  <span class="comment">// 构建新的 table ，大小为 32.</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">  Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">  table = newTab;</span><br><span class="line">  <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123; <span class="comment">// 进入扩容判断</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123; <span class="comment">// 遍历老容器</span></span><br><span class="line">      Node&lt;K,V&gt; e;</span><br><span class="line">      <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123; <span class="comment">// 如果老容器的该位置的值为空，就直接跳出这次循环</span></span><br><span class="line">        oldTab[j] = <span class="keyword">null</span>; <span class="comment">// 干掉老容器的每个值</span></span><br><span class="line">        <span class="keyword">if</span> (e.next == <span class="keyword">null</span>) <span class="comment">// 如果当前这个 e 后面没有元素了，把它进行重新 hash 过后，放在了新的表格里面</span></span><br><span class="line">          newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode) <span class="comment">// 如果是红黑树的话，进入红黑树的判断。</span></span><br><span class="line">          ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// preserve order : 保留顺序</span></span><br><span class="line">          Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; next;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">            next = e.next;</span><br><span class="line">            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">              loTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">              hiTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">          <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">            newTab[j] = loHead;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">            newTab[j + oldCap] = hiHead;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 table 当前的 size &gt; threshold 的时候，进行扩容，即大于边界值。</p>
<p>扩容过后的 table 的大小为之前的 * 2</p>
<p>扩容的边界为 旧的边界 * 2</p>
</li>
<li><h4 id="table-的-length-为什么要是-2-的-n-次幂？"><a href="#table-的-length-为什么要是-2-的-n-次幂？" class="headerlink" title="table 的 length 为什么要是 2 的 n 次幂？"></a>table 的 length 为什么要是 2 的 n 次幂？</h4><p>==不管你传值与否，不管你传入的长度多少，在你使用 HashMap 的时候，他的长度都是 2 的 n 次方，且最大长度为 2 的 30 次方==。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The maximum capacity, used if a higher value is implicitly specified</span></span><br><span class="line"><span class="comment">  * by either of the constructors with arguments.</span></span><br><span class="line"><span class="comment">  * MUST be a power of two &lt;= 1&lt;&lt;30.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br></pre></td></tr></table></figure>
<p>这个值，都用在以下几个地方：</p>
<ul>
<li>resize() 函数，用来进行扩容</li>
<li>tableSizeFor() ，用来扩容</li>
<li>构造函数中</li>
<li>putEntries()，存放一组 HashMap 元素时，不是存放单个。</li>
</ul>
<blockquote>
<p>注意，在源码中，采用了<code>延迟初始化操作</code>，也就是 table 只有在用到的时候才会进行初始化，如果你一直不使用，那么 table 的长度，一直都为 0.</p>
</blockquote>
<p>可以看看 hash 代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> h;</span><br><span class="line">  <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了能够得到更高效的减少碰撞，本来使用的是 % 进行运算，但是在计算机中，取余的效率，不如位运算，所以使用了 hash &amp; (length -1)，当 length 的长度为 2 的 n 次方的时候，hash % length == hash &amp; (length -1)。</p>
</li>
<li><h4 id="求索引的时候为什么是-h-amp-length-1-而不是-h-amp-length-更不是-h-length？"><a href="#求索引的时候为什么是-h-amp-length-1-而不是-h-amp-length-更不是-h-length？" class="headerlink" title="求索引的时候为什么是 h &amp; (length - 1),而不是 h &amp; length,更不是 h % length？"></a>求索引的时候为什么是 h &amp; (length - 1),而不是 h &amp; length,更不是 h % length？</h4><p>因为计算机中，位运算的效率，远高于 取余 的操作。</p>
<p>采用 h &amp; (length -1) 而不是采用 h &amp; length 的原因是因为，采用前面这个的原因，主要原因是，h&amp; (length -1)的碰撞效率，低于 h &amp; length;</p>
</li>
<li><h4 id="为什么加载因子的默认值是-0-75？并且不推荐我们修改？"><a href="#为什么加载因子的默认值是-0-75？并且不推荐我们修改？" class="headerlink" title="为什么加载因子的默认值是 0.75？并且不推荐我们修改？"></a>为什么加载因子的默认值是 0.75？并且不推荐我们修改？</h4><p>0.75 是一个经验取出来的值，暂时没有去深究为什么需要采用 0.75。</p>
</li>
<li><h4 id="HashMap-为什么是线程不安全的？为什么扩容的时候会出现死锁？"><a href="#HashMap-为什么是线程不安全的？为什么扩容的时候会出现死锁？" class="headerlink" title="HashMap 为什么是线程不安全的？为什么扩容的时候会出现死锁？"></a>HashMap 为什么是线程不安全的？为什么扩容的时候会出现死锁？</h4></li>
</ul>
]]></content>
      <categories>
        <category>Hashmap</category>
      </categories>
      <tags>
        <tag>Hashmap</tag>
      </tags>
  </entry>
  <entry>
    <title>HotSpot虚拟机对象探秘</title>
    <url>/2021/02/05/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98/</url>
    <content><![CDATA[<h1 id="JVM学习笔记-HotSpot虚拟机对象探秘"><a href="#JVM学习笔记-HotSpot虚拟机对象探秘" class="headerlink" title="JVM学习笔记-HotSpot虚拟机对象探秘"></a>JVM学习笔记-HotSpot虚拟机对象探秘</h1><blockquote>
<p>大部分笔记内容都从 学习 <a href="https://doocs.gitee.io/jvm/#/docs/01-jvm-memory-structure">https://doocs.gitee.io/jvm/#/docs/01-jvm-memory-structure</a> 此文章和书籍：《深入理解Java虚拟机-jvm高级特性与最佳实践-第3版》而来，笔记中除了图片，其余都是纯粹手打，希望借这个能够更加熟悉关于jvm的知识。</p>
</blockquote>
<h2 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h2><h2 id="1-对象的内存布局"><a href="#1-对象的内存布局" class="headerlink" title="1. 对象的内存布局"></a>1. 对象的内存布局</h2><p>在HotSpot虚拟机中，对象的内存布局分为以下3块区域：</p>
<ul>
<li>对象头</li>
<li>实例数据</li>
<li>对齐填充</li>
</ul>
<p>如图所示：<img src="/2021/02/05/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png" alt="对象内存布局"></p>
<h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p>对象头记录了对象在运行过程中所需要使用的一些数据：</p>
<ul>
<li>哈希码</li>
<li>GC分代年龄</li>
<li>锁状态标志</li>
<li>线程持有的锁</li>
<li>偏向线程ID</li>
<li>偏向时间戳</li>
</ul>
<p>对象头可能包含类型指针，通过该指针能确定对象属于哪个类。如果对象是一个数组，那么对象头还会包含数组长度。</p>
<a id="more"></a>

<h4 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h4><p>实例数据部分就是成员变量的值，其中包括父类成员变量和本类的成员变量。</p>
<h4 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h4><p>用于确保对象的总长度为8字节的整数倍。</p>
<p>HotSpot VM的自动内存管理系统要求对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数(1倍或者2倍)</p>
<blockquote>
<p>对齐填充并不是必然存在，也没有特别的含义，它仅仅起着占位符的作用。</p>
</blockquote>
<h2 id="2-对象的创建过程"><a href="#2-对象的创建过程" class="headerlink" title="2. 对象的创建过程"></a>2. 对象的创建过程</h2><ul>
<li><h4 id="类加载检查"><a href="#类加载检查" class="headerlink" title="类加载检查"></a>类加载检查</h4><p>虚拟机在解析.class文件时，若遇到一条new指令，首先它会去检查常量池中是否存在这个类的符号引用，并且检查这个符号引用对应的对象是否被加载、解析、实例化过。如果没有，那么就必须执行对应的加载过程。</p>
</li>
<li><h4 id="为新生对象分配内存"><a href="#为新生对象分配内存" class="headerlink" title="为新生对象分配内存"></a>为新生对象分配内存</h4><p>对象所需内存的大小在类加载完成过后就会完全确定，接下来从堆中划分一块对应大小的内存空间给新的对象。分配堆中内存有两种方式：</p>
<ul>
<li><p>指针碰撞</p>
<p>如果Java<strong>堆中内存绝对规整(说明采用的是“复制算法”或“标记整理法”)，空闲内存和已使用内存中间存放着一个指针作为分界点指示器，那么分配内存时，只需要把指针向空闲内存挪动一段与对象大小一样的距离，这种分配方式成为<strong>“指针碰撞”</strong>。</strong></p>
</li>
<li><p>空闲列表</p>
<p>如果Java<strong>堆中内存并不规整</strong>，已经使用的内存和空闲内存交错（说明使用的是标记-清除 算法，有碎片），此时没法简单进行指针碰撞，VM必须维护一个列表，记录其中哪些内存块空闲可用。分配之时从空闲列表中找到一个足够大的内存空间划分给对象实例。这种方式成为<strong>“空闲列表”</strong>。</p>
</li>
</ul>
</li>
<li><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>分配完内存过后，为对象中的成员变量赋上初始值，设置对象头信息，调用对象的构造函数方法进行初始化。</p>
<p>至此，整个对象的创建过程就完了。</p>
</li>
</ul>
<h2 id="3-对象的访问方式"><a href="#3-对象的访问方式" class="headerlink" title="3. 对象的访问方式"></a>3. 对象的访问方式</h2><p>所有对象的存储空间都是在堆中分配的，但是这个对象的引用确实在堆栈中分配的。也就是说在建立一个对象时，两个地方都在分配内存，在堆中分配的内存实际建立这个对象，而在堆栈中分配的内存只是一个指向这个堆对象的指针(引用)而已。那么根据引用存放的地址类型的不同，对象有不同的访问方式。</p>
<ul>
<li><p>句柄访问方式</p>
<p>堆中需要一块叫做“句柄池”的内存空间，句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p>
<p>引用类型的变量存放的是该对象的句柄地址。访问对象时，首先需要通过引用类型的变量找到该对象的句柄。然后根据句柄中对象的地址找到对象。</p>
<p><img src="/2021/02/05/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98/%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F.jpg" alt="句柄访问方式"></p>
</li>
<li><p>直接指针访问方式</p>
<p>引用类型的变量直接存放对象的地址，从而不需要句柄池，通过引用能够直接访问对象。但对象所在的内存空间需要额外的策略储存对象所属的类信息的地址。</p>
<p><img src="/2021/02/05/JVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98/%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE.jpg" alt="直接指针访问"></p>
<blockquote>
<p>需要说明，HotSpot采用的第二种方式，即直接指针方式来访问对象，只需要一次寻址操作，所以在性能上比句柄访问方式快一倍。但像上面所说，它需要额外的策略来储存对象在方法池中类信息的地址。</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM运行时内存区域</title>
    <url>/2021/05/26/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
    <content><![CDATA[<h1 id="JVM运行时内存区域"><a href="#JVM运行时内存区域" class="headerlink" title="JVM运行时内存区域"></a>JVM运行时内存区域</h1><blockquote>
<p>本文参考于《深入理解Java虚拟机》第三版</p>
</blockquote>
<p>根据《 Java 虚拟机规范》的规定，Java 虚拟机所管理的内存将会包括以下几个运行时数据区域：</p>
<ul>
<li><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>  具体内容参考这篇文章：<a href="https://blog.csdn.net/Sopp_Li/article/details/117224149">程序计数器-JVM</a></p>
</li>
<li><h2 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h2><p>  Java 虚拟机栈，类似于程序计数器，也是线程私有的，它的生命周期和线程相同。<br>  虚拟机栈描述的是Java方法执行的线程模型：每个方法被执行的时候，Java虚拟机都会同步创建一个<code>栈帧</code>，用于存储</p>
<ul>
<li><code>局部变量表</code>、指向了 8 大原始类型、对象引用</li>
<li><code>操作数栈</code>、</li>
<li><code>动态连接</code>、</li>
<li><code>方法出口</code></li>
<li><code>栈帧</code>等信息。每一个方法被调用直至执行完毕的过程，就对应一个栈帧在虚拟机栈的出栈和入栈的功能。</li>
</ul>
  <a id="more"></a>
<p>  具体如下图：</p>
<p>  <img src="/2021/05/26/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/jvm-stack.jpg" alt="jvm-stack"></p>
<p>  压栈和出栈的过程分析：<br>  当方法运行过程中，需要创建局部变量的时候，就讲局部变量的值存入栈帧中的局部变量表中。</p>
<p>  Java虚拟机栈的栈顶的栈帧是当前正在执行的活动栈，也就是当前正在执行的方法，PC 寄存器也会指向这个地址。只有这个活动的栈帧的本地变量可以被操作数栈使用，当这个栈帧中调用另一个方法，与之对应的栈帧又会被创建，新创建的栈帧压入栈顶，变为当前的活动栈帧。</p>
<p>  方法结束过后，当前栈帧被移除，栈帧的返回值变化成新的活动栈帧中操作数栈的一个操作数。如果没有返回值，那么新的活动栈帧操作数栈的操作数没有变化。</p>
<blockquote>
<p><strong>由于 Java 虚拟机栈是与线程同步的，数据不是线程共享的，因此不用关心数据一致性问题，也不会存在同步锁的问题。</strong></p>
</blockquote>
<h3 id="Java虚拟机栈的特点："><a href="#Java虚拟机栈的特点：" class="headerlink" title="Java虚拟机栈的特点："></a>Java虚拟机栈的特点：</h3><ul>
<li>局部变量表随着栈帧的创建而创建，它的大小在编译时确定，创建时只需要分配事先规定的大小即可。在方法运行过程中，局部变量表不会发生改变。</li>
<li>Java虚拟机栈会出现两种异常： `StackOverFlowError 和 OutOfMemoryError。<ul>
<li>StackOverFlowError 若 Java 虚拟机栈的大小不允许动态扩展，那么当线程请求栈的深度超过当前的 Java 虚拟机栈的最大深度的时候，就会抛出该异常。</li>
<li>OutOfMemoryError 若允许动态扩展，那么当线程请求栈时内存用完了，无法再动态扩展时，抛出该异常。</li>
</ul>
</li>
<li>Java 虚拟机栈也是线程私有，随着线程创建而创建，随着线程的结束而销毁。</li>
</ul>
<blockquote>
<p>出现 StackOverFlowError 时，内存空间可能还有很多。</p>
</blockquote>
</li>
<li><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><h3 id="本地方法栈的定义"><a href="#本地方法栈的定义" class="headerlink" title="本地方法栈的定义"></a>本地方法栈的定义</h3><p>本地方法栈是为 JVM 运行 Native 方法而准备的空间，由于很多 Native 方法都是 C 语言实现的，所以通常它又叫做 C 栈。它与 Java 虚拟机栈实现的功能类似，只不过本地方法栈是描述本地方法运行过程的内存模型。</p>
<h3 id="栈帧变化的过程"><a href="#栈帧变化的过程" class="headerlink" title="栈帧变化的过程"></a>栈帧变化的过程</h3><p>本地方法被执行时，在本地方法栈也会创建一块栈帧，用于存放该方法的局部变量表、操作数栈、动态连接、方法出口信息等。</p>
<p>方法执行结束过后，相应的栈帧也会出栈，并释放内存空间。也会抛出 StackOverFlowError 和 OutOfMemoryError 异常。</p>
<blockquote>
<p>如果 Java 虚拟机本身不支持 Native 方法，或者本身不依赖传统栈，那么可以不提供本地方法栈。如果支持本地方法栈，那么这个栈一般会在线程创阿金的时候按线程分配。</p>
</blockquote>
</li>
<li><h2 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h2><h3 id="堆的定义："><a href="#堆的定义：" class="headerlink" title="堆的定义："></a>堆的定义：</h3><p>堆是用来存放对象的内存空间，几乎所有的对象都储存在堆中。</p>
<h3 id="堆的特点："><a href="#堆的特点：" class="headerlink" title="堆的特点："></a>堆的特点：</h3><ul>
<li>线程共享，整个 Java 虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java 虚拟机栈、本地方法栈都是一个线程对应一个。</li>
<li>在虚拟机启动的时候创建。</li>
<li>是垃圾回收的主要场所。</li>
<li>进一步可以分为：<code>新生代</code>、<code>老年代</code>。</li>
</ul>
<p>不同区域存放不同生命周期的对象，这样可以根据不同的区域使用不同的垃圾回收算法，更具有针对性。</p>
<p>堆的大小即可以固定也可以扩展，但是对于主流的虚拟机，堆的大小是可以扩展的，因此当线程请求分配内存，但是堆已经满了，且内存已经无法再扩展时，就抛出 OOM 异常。</p>
<blockquote>
<p>Java 堆所使用的的内存不需要保证是连续的。而由于堆是被所有线程所共享的。所以对它的访问需要注意同步问题，方法和对应的属性都要保证一致性。</p>
</blockquote>
</li>
<li><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><h3 id="方法区的定义"><a href="#方法区的定义" class="headerlink" title="方法区的定义"></a>方法区的定义</h3><p>Java 虚拟机规范中定义方法区是堆的一个逻辑部分。方法去存放以下信息：</p>
<ul>
<li>已经被虚拟机加载的类信息</li>
<li>常量 &amp;&amp; 静态常量</li>
<li>即时编译器编译过后的代码</li>
</ul>
<h3 id="方法区的特点"><a href="#方法区的特点" class="headerlink" title="方法区的特点"></a>方法区的特点</h3><ul>
<li>线程共享。方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。<code>整个虚拟机中只有一个方法区</code>。</li>
<li>永久代。方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，把方法区称为“永久代”。</li>
<li>内存回收效率低。方法区中的信息一般需要长期存在，回收一遍之后可能只有少量信息无效。主要回收目标是：<ul>
<li>对常量池的回收；</li>
<li>对类型的卸载。</li>
</ul>
</li>
<li>Java 虚拟机规范对方法区的要求比较宽松。和堆一样，允许固定大小，也允许动态扩展，还允许不实现垃圾收集。</li>
</ul>
</li>
<li><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>方法区中存放： 类信息、常量、静态常量、即时编译器编译过后的代码。常量就存放在运行时常量池中。</p>
<p>当类被 Java 虚拟机加载过后，.class 文件中的常量就存放在方法区中的运行时常量池中。而且在运行期间，可以向常量池中添加新的常量。如 String 类的 </p>
<p>intern() 方法就能在运行期间向常量池中添加字符串常量。</p>
</li>
<li><h2 id="直接内存-也叫堆外内存"><a href="#直接内存-也叫堆外内存" class="headerlink" title="直接内存(也叫堆外内存)"></a>直接内存(也叫堆外内存)</h2><p>直接内存时除开 Java 虚拟机之外的内存，但是也可以被 Java 使用。</p>
<h3 id="操作直接内存"><a href="#操作直接内存" class="headerlink" title="操作直接内存"></a>操作直接内存</h3><p>在 NIO 中引入了一种基于通道和缓冲的 IO 方式。它可以通过调用本地方法直接分配 Java 虚拟机之外的内存，然后通过一个储存在堆中的 DirectByteBuffer 对象直接操作该内存，而无需先将外部内存中的数据复制到堆中再进行操作，从而提高了数据库操作的效率。</p>
<p>直接内存的大小不受 Java 虚拟机的控制，但是既然是内存，当内存不足的时候，也会出现 OOM 异常。</p>
<h3 id="直接内存与堆内存比较"><a href="#直接内存与堆内存比较" class="headerlink" title="直接内存与堆内存比较"></a>直接内存与堆内存比较</h3><ul>
<li>直接内存申请空间耗费更高的性能</li>
<li>直接内存读取 IO 的性能要优于普通的堆内存。</li>
<li>直接内存作用链： 本地 IO -&gt; 直接内存 -&gt; 本地 IO</li>
<li>堆内存作用链：本地 IO -&gt; 直接内存 -&gt; 非直接内存 -&gt; 直接内存 -&gt; 本地 IO</li>
</ul>
<blockquote>
<p>服务器管理员在配置虚拟机参数时，会根据实际内存设置 -Xmx 等参数信息，但经常<br>忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出<br>现 OutOfMemoryError 异常。</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 5种IO模型</title>
    <url>/2021/06/01/Linux%205%E7%A7%8DIO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="Linux-5种IO模型"><a href="#Linux-5种IO模型" class="headerlink" title="Linux 5种IO模型"></a>Linux 5种IO模型</h1><h2 id="阻塞式IO模型"><a href="#阻塞式IO模型" class="headerlink" title="阻塞式IO模型"></a>阻塞式IO模型</h2><p>最传统的一种IO模型，即在读写的过程中会发生阻塞现象。</p>
<p>当用户线程发出IO请求过后，内核回去查看数据是否就绪，如果没有就绪，就等待数据就绪，而用户线程会阻塞，用户线程交出CPU。当数据就绪过后，内核会把</p>
<p>数据拷贝到用户线程中，并返回结果给用户线程，用户线程才解除 <code>broken</code> 状态。</p>
<p>典型的阻塞IO模型的例子如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">data = socket.read();</span><br></pre></td></tr></table></figure>
<p>如果数据没有就绪，就会一直阻塞在read方法。</p>
<a id="more"></a>

<h2 id="非阻塞式IO模型"><a href="#非阻塞式IO模型" class="headerlink" title="非阻塞式IO模型"></a>非阻塞式IO模型</h2><p>当用户线程发起一个 read 操作过后，并不需要等待，而是马上就得到了一个结果。如果结果是一个 error 时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦内核中数据准备好了，并且又再一次接收到了用户线程的请求，那么它马上就会将数据拷贝到用户线程，然后返回。</p>
<p>所以事实上，在非阻塞IO模型中，用户线程需要不断地询问内核数据是否已经就位，也就是非阻塞IO不会交出 CPU，而会一直占用CPU。</p>
<p>典型的非阻塞IO模型一般如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">	data = socket.read();</span><br><span class="line">	<span class="keyword">if</span>(data != error)&#123;</span><br><span class="line">		<span class="comment">//TODO 在这里处理你的数据</span></span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 但是对于非阻塞IO就有一个非常严重的问题，在 while 循环中需要不断地去询问内核数据是否已经就绪，这样会导致CPU占用非常，因此一般很少使用while循环这种方式来读取数据。</p>
<h2 id="IO复用模型"><a href="#IO复用模型" class="headerlink" title="IO复用模型"></a>IO复用模型</h2><p>多路复用IO模型就是目前使用的比较多的模型。Java NIO 实际上就是多路复用IO。</p>
<p>在多路复用IO模型中，会有一个线程不断去轮询多个 socket 的状态，只有当 socket 真正有读写事件的时候，才会真正调用实际的 IO 读写操作。因为在多路复用 </p>
<p>IO 模型中，只需要使用一个线程就可以管理多个 socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有 socket 读写事件</p>
<p>时，才会使用 IO 资源，所以它大大减少了资源占用。</p>
<p>在 Java NIO 中，，是通过 selector.select() 去查询每一个通道是否有到达事件，如果没有事件，则一直阻塞在哪里，因此这种方式会导致用户线程的阻塞。</p>
<p>也有人说可，可以采用 多线程 + 阻塞IO 到达类似的效果，但是由于在 多线程+阻塞IO 中，每个 socket 对应一个线程，这样会造成很大的资源占用，并且尤其对于长连接来说，线程的资源一直不会释放，如果后续有很多连接的话，就会造成性能上的瓶颈。</p>
<p>而多路复用模式，通过一个线程就可以管理多个 socket，只有当 socket 真正有读写事件发生才会占用资源来进行实际的读写操作。因此多路复用IO比较适合连接数比较多的情况。</p>
<p>另外多路复用IO为何比非阻塞IO模型的效率高是因为在非阻塞IO中，不断地轮询 socket 状态是通过用户线程去做的，而在多路复用IO中，轮询每个 socket 状态是在内核中进行的，这个效率要比用户线程高得多。</p>
<p>不过要注意的是，多路复用IO模型是通过轮询的方式来检测是否事件到达，并且对到达的事件逐一进行相应。因此对于多路复用IO模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。</p>
<h2 id="信号驱动IO模型"><a href="#信号驱动IO模型" class="headerlink" title="信号驱动IO模型"></a>信号驱动IO模型</h2><p>在信号驱动IO模型中，当用户线程发起一个IO请求操作，会给对应的socket注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用</p>
<p>户线程，用户线程接收到信号过后，便在信号函数中调用IO读写操作来进行实际的IO操作。</p>
<h2 id="异步IO模型"><a href="#异步IO模型" class="headerlink" title="异步IO模型"></a>异步IO模型</h2><p>异步IO模型是比较理想的IO模型，在异步IO模型中，当用户线程发起 read 操作之后，立刻就可以开始去做其他的事。而另一方面，从内核的角度，当它受到一个 </p>
<p>asynchronous read 之后，它会立刻返回，说明 read 请求已经成功发起了，因此不会对用户线程产生任何 block。然后，内核会等待数据准备完成，然后将数据</p>
<p>拷贝到用户线程，当一切都完成之后，内核会给用户线程发送一个信号，告诉它 read 操作完成了。也就是说用户线程完全不需要知道实际的整个IO操作是如何进</p>
<p>行，只需要先发起一个请求，当接收内核返回的成功信号时表示IO操作已经完成，可以直接去使用数据了。</p>
<p>也就是说在异步IO模型中，IO操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成的，然后发送一个信号告知用户线程操作已经完成。用户线程</p>
<p>不需要再次调用IO函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号，表示用户数据已经就绪，然后需要用户</p>
<p>线程调用IO函数进行实际的读写操作；而在异步IO模型中，收到信号表示IO操作已经完成，不需要再在用户线程中调用IO函数进行实际的读写操作。</p>
<p>注意，异步IO是需要操作系统的底层支持，在 Java 7 中，提供了 Asynchronous IO。</p>
<p>前面四种IO模型实际上都属于同步IO，只有最后一种是真正的异步IO，因为无论是多路复用IO还是信号驱动模型，IO操作的第2个阶段都会引起用户线程阻塞，也</p>
<p>就是内核进行数据拷贝的过程都会让用户线程阻塞。</p>
]]></content>
      <categories>
        <category>I/O</category>
      </categories>
      <tags>
        <tag>I/O</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合</title>
    <url>/2021/06/20/Java%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="Java集合"><a href="#Java集合" class="headerlink" title="Java集合"></a>Java集合</h1><p>Java集合中，最主要包括两种数据结构：</p>
<ul>
<li>Collection</li>
<li>Map</li>
</ul>
<p>参考下图，就是集合的相互关系图：</p>
<p><img src="/2021/06/20/Java%E9%9B%86%E5%90%88/list_framework.png?lastModify=1624156273" alt="list_framework"></p>
<h2 id="List、Set、Map-的区别和用途？"><a href="#List、Set、Map-的区别和用途？" class="headerlink" title="List、Set、Map 的区别和用途？"></a>List、Set、Map 的区别和用途？</h2><ul>
<li>List 有序，可以重复，与数据结构类似，多用于数据顺序存储，</li>
<li>Set 无序，不重复，多用于唯一性。</li>
<li>Map key-value格式，用于存放键值对映射，比如存放后端返回前端的json映射。</li>
</ul>
<a id="more"></a>

<h2 id="List-及底层集合的知识："><a href="#List-及底层集合的知识：" class="headerlink" title="List 及底层集合的知识："></a>List 及底层集合的知识：</h2><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>类似于 Object[] 数组，方便快速查找。优点是方便查找。</p>
<h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>双向链表，在 Jdk 1.6之前是循环链表，1.7 过后取消了循环。优点是方便插入和删除。</p>
<h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>Object[] 数组，很早版本的 Jdk 便存在了，很早前用于并发处理的同步集合，缺点很明显，并发处理速度慢(由于 Vector 底层方法都用 <code>synchronize</code> 关键字加了锁的)。</p>
<h2 id="Set及底层集合"><a href="#Set及底层集合" class="headerlink" title="Set及底层集合"></a>Set及底层集合</h2><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>基于  <code>HashMap</code> 实现，底层采用 <code>HashMap</code> 来保存元素。无序的，且唯一。</p>
<h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>Set 中实现了 SortedSet 的排序接口，特点是唯一、不重复。底层实现为<code>红黑树</code>。</p>
<h3 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h3><p>是 HashSet 的子类，底层通过 <code>LinkedHashMap</code> 来实现的。</p>
<h2 id="Map-及底层集合"><a href="#Map-及底层集合" class="headerlink" title="Map 及底层集合"></a>Map 及底层集合</h2><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>Jdk 1.8 之前，通过 <code>数组+链表</code> 的方式来实现的，数组是 HashMap 的主体，链表则主要是为了解决 <code>Hash冲突</code> 而存在的(<code>拉链法</code> 解决)。Jdk 1.8 过后，在解决冲突的方法上有很大的改变，当链表长度大于 8 的时候，会将当前链表转换为 <code>红黑树</code> 来加快索引的速度，如果当链表长度小于 8 的时候，又会自动从红黑树转换为链表。</p>
<blockquote>
<p>有意思的是，在链表长度大于 8 的时候，不会马上进行红黑树的转换，而是会先判断数组的长度是否大于64，如果小于64，就会先扩容数组的大小到64 来减少哈希碰撞的概率，后续不够的情况，才会转换为红黑树。</p>
</blockquote>
<h3 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h3><p>继承自 HashMap ，所以它的底层仍然是基于<code>拉链式</code> 散列结构即由<code>数组+链表/红黑树</code>组成。另外，LinkedHashMap 在上面结构的基础上，增加了 一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作， 实现了访问顺序相关逻辑。</p>
<h3 id="Hashtable"><a href="#Hashtable" class="headerlink" title="Hashtable"></a>Hashtable</h3><p>数组 + 链表 组成的，本来 Hashtable 的底层就是 HashMap 实现的。</p>
<h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><p>底层为红黑树(自平衡的二叉树)的一种 Map 集合。</p>
<h2 id="如何选用集合？"><a href="#如何选用集合？" class="headerlink" title="如何选用集合？"></a>如何选用集合？</h2><p>首先应该是根据具体的使用场景再结合集合的特点来选择。比如，需要 key-value 的时候，首先想到map，如果不需要使用排序，首先想到 HashMap，如果需要使用排序，则为 TreeMap，需要保证线程安全的时候，选用 ConcurrentHashMap。</p>
<p>当我们只需要存放元素的时候，选用 Collection 接口的集合，保证唯一性，选用 TreeSet/HashSet。不需要就选用 ArrayList/LinkedList。剩下的都根据对应集合的特点来使用。</p>
<h2 id="为啥需要使用集合？"><a href="#为啥需要使用集合？" class="headerlink" title="为啥需要使用集合？"></a>为啥需要使用集合？</h2><p>其实很多人在学习的时候，就会想一个问题，其实集合的作用，很多的时候跟数组的作用是差不多的，那么，为什么更多的时候，不使用数组，而使用集合呢？其实很好理解：</p>
<ol>
<li>数组的格式单一，必须在创建的时候指定，没有办法使用泛型来对程序的灵活性进行扩展。</li>
<li>数组的大小是指定的，没有办法动态扩容。</li>
<li>数组是没有键值对的格式的，如果需要键值对，就洗白。</li>
<li>数组是有序的，可重复的，那么就无法满足我们某些特定场景下的需求。</li>
</ol>
<h2 id="集合的遍历："><a href="#集合的遍历：" class="headerlink" title="集合的遍历："></a>集合的遍历：</h2><h3 id="Iterator-迭代器"><a href="#Iterator-迭代器" class="headerlink" title="Iterator 迭代器"></a>Iterator 迭代器</h3><p>Iterator 对象叫做迭代器(设计模式的一种：迭代器模式)，迭代器可以用来遍历集合对象，但是每一个 集合的内部数据结构可能是不一样的，所以每一个集合的存和取得方式可能完全不同，虽然我们可以在每一个类中定义 hasNext() 和 next() 方法来进行遍历，但是这样会让集合的体系过于臃肿。</p>
<p>迭代器是将 hasNext() 和 next() 方法抽离出接口中，然后在每一个类的内部，自行定义自己的迭代方法，这样就约束了每一个集合的遍历方法都是 hasNext() 和 next() 了，使用者不需要了解怎么实现，只需要能用，就够了。</p>
<p>迭代器就是提供一种方法访问一个容器对象的每一个元素，但是有不需要暴露该对象的内部细节。</p>
<p>常见操作方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Iterator it &#x3D; list.iterator();</span><br><span class="line">while(it.hasNext()) &#123;</span><br><span class="line">　　Object obj &#x3D; it.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="常见集合的遍历方式"><a href="#常见集合的遍历方式" class="headerlink" title="常见集合的遍历方式"></a>常见集合的遍历方式</h3><h4 id="Map-的遍历方式"><a href="#Map-的遍历方式" class="headerlink" title="Map 的遍历方式"></a>Map 的遍历方式</h4><ul>
<li><p>通过 Map 的 key 来进行遍历</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;(16);</span><br><span class="line">&#x2F;&#x2F;得到所有key的集合</span><br><span class="line">Set&lt;Integer&gt; set &#x3D; map.keySet(); </span><br><span class="line">for (Integer in : map.keySet()) &#123;</span><br><span class="line">  &#x2F;&#x2F;得到每个key多对用value的值</span><br><span class="line">  String str &#x3D; map.get(in);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>通过 Map.entrySet 使用 iterator 遍历 key 和 value</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;(16);</span><br><span class="line">Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; it &#x3D; map.entrySet().iterator();</span><br><span class="line">while (it.hasNext()) &#123;</span><br><span class="line">  Map.Entry&lt;Integer, String&gt; entry &#x3D; it.next();</span><br><span class="line">  System.out.println(&quot;key&#x3D; &quot; + entry.getKey() + &quot; and value&#x3D; &quot; +  entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>通过 Map.entrySet 遍历 key 和 value，推荐，尤其是容量大时</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for (Map.Entry&lt;Integer, String&gt; entry : map.entrySet()) &#123;</span><br><span class="line">  &#x2F;&#x2F; Map.entry&lt;Integer,String&gt; 映射项（键-值对)</span><br><span class="line">  &#x2F;&#x2F; entry.getKey(); entry.getValue(); entry.setValue();</span><br><span class="line">  &#x2F;&#x2F; map.entrySet(): 返回此映射中包含的映射关系的 Set视图。</span><br><span class="line">  System.out.println(&quot;key&#x3D; &quot; + entry.getKey() + &quot; and value&#x3D; &quot; + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>通过Map.values()遍历所有的value，但不能遍历key</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map &#x3D; new HashMap&lt;&gt;(16);</span><br><span class="line">for (String value : map.values()) &#123;</span><br><span class="line">  System.out.println(&quot;value&#x3D; &quot; + value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="List-遍历方式"><a href="#List-遍历方式" class="headerlink" title="List 遍历方式"></a>List 遍历方式</h4></li>
<li><p>第一种</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List list &#x3D; new ArrayList();</span><br><span class="line">for(Iterator iterator &#x3D; list.iterator();iterator.hasNext();)&#123;                    </span><br><span class="line">    int i &#x3D; (Integer) iterator.next();                   </span><br><span class="line">    System.out.println(i);               </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>第二种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List list &#x3D; new ArrayList();</span><br><span class="line">Iterator iterator &#x3D; list.iterator();</span><br><span class="line">while(iterator.hasNext())&#123;</span><br><span class="line">    int i &#x3D; (Integer) iterator.next();</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>第三种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List list &#x3D; new ArrayList();</span><br><span class="line">for (Object object : list) &#123; </span><br><span class="line">    System.out.println(object); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第四种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List list &#x3D; new ArrayList();</span><br><span class="line">for(int i &#x3D; 0 ;i&lt;list.size();i++) &#123;  </span><br><span class="line">    int j&#x3D; (Integer) list.get(i);</span><br><span class="line">    System.out.println(j);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Set-遍历方式"><a href="#Set-遍历方式" class="headerlink" title="Set 遍历方式"></a>Set 遍历方式</h4></li>
<li><p>第一种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;方法1 集合类的通用遍历方式, 从很早的版本就有, 用迭代器迭代</span><br><span class="line">Set&lt;String&gt; set &#x3D; new HashSet();</span><br><span class="line">Iterator iterator &#x3D; set.iterator();</span><br><span class="line">while(iterator.hasNext())&#123;</span><br><span class="line">		System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>第二种：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; set &#x3D; new HashSet();</span><br><span class="line">for(Iterator iterator &#x3D; set.iterator();it2iteratorhasNext();)&#123;</span><br><span class="line">  	System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>第三种:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Set&lt;String&gt; set &#x3D; new HashSet();</span><br><span class="line">for(String value: set)&#123;</span><br><span class="line">  	System.out.println(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP/IP的理解</title>
    <url>/2021/01/14/TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="对于TCP-IP的理解"><a href="#对于TCP-IP的理解" class="headerlink" title="对于TCP/IP的理解"></a>对于TCP/IP的理解</h1><p>&emsp;在很多人面试的时候，都遇见过招聘要求上要求这一项</p>
<blockquote>
<p>精通TCP/IP，熟练使用Socket进行网络编程。</p>
</blockquote>
<p>看到这句话，贼提莫熟悉，很多人都觉得这些东西，在我们实际的开发中遇不到，楼主在很早之前也是一样的想法，但是越工作，就越来越觉得这些知识很重要。<br>下面我们就来了解以下什么是TCP/IP。</p>
<h2 id="一、什么是TCP-IP"><a href="#一、什么是TCP-IP" class="headerlink" title="一、什么是TCP/IP"></a>一、什么是TCP/IP</h2><p>tcp/ip是一类协议系统，它是用于网络通信的一套协议的集合。<br>传统的tcp/ip被认为是一个四层的协议系统。</p>
<table>
  <tr>
    <th>OSI体系结构</th>
    <th colspan="2">TCP/IP协议集合</th>
  </tr>

  <tr>
    <td>应用层</td>
    <td rowspan="3">应用层</td>
    <td rowspan="3">TELNET、FTP、HTTP、SMTP、DNS等</td>
  </tr>
  <tr>
    <td>表示层</td>
  </tr>
  <tr>
    <td>会话层</td>
  </tr>

  <tr>
    <td>传输层</td>
    <td>传输层</td>
    <td>TCP、UDP</td>
  </tr>
  <tr>
    <td>网络层</td>
    <td>网络层</td>
    <td>IP、ICMP、ARP、RARP</td>
  </tr>
  <tr>
    <td>数据链路层</td>
    <td rowspan="2">网络层</td>
    <td rowspan="2">各种物理通信网络接口</td>
  </tr>
  <tr>
    <td>物理层</td>
  </tr>
</table>

<a id="more"></a>

<p>对应体系结构解释：</p>
<h3 id="1-1-网络接口层"><a href="#1-1-网络接口层" class="headerlink" title="1.1 网络接口层"></a>1.1 网络接口层</h3><p>主要是值物理层次的一些接口，比如电缆等。</p>
<h3 id="1-2-网络层"><a href="#1-2-网络层" class="headerlink" title="1.2 网络层"></a>1.2 网络层</h3><p>提供独立于硬件的逻辑寻址，实现物理地址与逻辑地址的转换。<br>在TCP/IP协议族中，网络层协议包括IP协议(网际协议)，ICMP协议(Internet互联网控制报文协议)，以及IGMP协议(Internet组管理协议)。</p>
<h3 id="1-3-传输层"><a href="#1-3-传输层" class="headerlink" title="1.3 传输层"></a>1.3 传输层</h3><p>为网络层提供了流量控制，错误控制和确认服务。<br>在TCP/IP协议族中，由两个互不相同的传输协议：TCP(传输控制协议)和UDP(用户数据报协议)。</p>
<h3 id="1-4-应用层"><a href="#1-4-应用层" class="headerlink" title="1.4 应用层"></a>1.4 应用层</h3><p>为网络拍错，文件传输，远程控制和Internet操作提供具体的应用程序。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>docker容器mysql时间不同步</title>
    <url>/2021/01/14/docker%E5%AE%B9%E5%99%A8mysql%E6%97%B6%E9%97%B4%E4%B8%8D%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="docker容器mysql时间不同步问题"><a href="#docker容器mysql时间不同步问题" class="headerlink" title="docker容器mysql时间不同步问题"></a>docker容器mysql时间不同步问题</h1><p>最近由于项目中需要进行时间同步，刚好项目中需要使用到docker，所以从docker方面入手进行时间同步。</p>
<blockquote>
<p>每日一点学习，加油~</p>
</blockquote>
<ol>
<li>首先进行容器和主机的时间同步。<br>在docker-compose的配置文件中，使用/etc/localtime:/etc/localtime参数进行容器时间同步。具体的示例如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql:</span><br><span class="line">    build:</span><br><span class="line">      #dockerfile的路径</span><br><span class="line">      context: .&#x2F;mysql</span><br><span class="line">      #dockerfile的名称</span><br><span class="line">      dockerfile: Dockerfile</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;3307:3306&quot;</span><br><span class="line">    #相当于docker run命令中的-e</span><br><span class="line">    environment:</span><br><span class="line">      - &quot;MYSQL_ROOT_PASSWORD&#x3D;root&quot;</span><br><span class="line">      #初始化的数据库名称</span><br><span class="line">      - &quot;MYSQL_DATABASE&#x3D;test_compose&quot;</span><br><span class="line">      - &quot;MYSQL_ROOT_HOST&#x3D;%&quot;</span><br><span class="line">    #容器名称</span><br><span class="line">    container_name: mysql-compose</span><br><span class="line">    restart: always</span><br><span class="line">    #数据卷映射关系，也就是把本地的目录，和mysql容器中的目录，进行对应映射。</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;.&#x2F;mysql&#x2F;data&#x2F;:&#x2F;var&#x2F;lib&#x2F;mysql&quot;</span><br><span class="line">      - &quot;&#x2F;etc&#x2F;localtime:&#x2F;etc&#x2F;localtime&quot;</span><br></pre></td></tr></table></figure>
说明：<br>这里最重要的即为 /etc/localtime:/etc/localtime，使用这个配置，对docker容器和外部主机的时间进行同步。</li>
</ol>
<a id="more"></a>

<ol start="2">
<li>如果容器中存在mysql等，那么即需要同步mysql的时间与mysql容器的时间。一般默认为配置mysql默认时区即可。具体示例如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql:</span><br><span class="line">    build:</span><br><span class="line">      #dockerfile的路径</span><br><span class="line">      context: .&#x2F;mysql</span><br><span class="line">      #dockerfile的名称</span><br><span class="line">      dockerfile: Dockerfile</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;3307:3306&quot;</span><br><span class="line">    #相当于docker run命令中的-e</span><br><span class="line">    environment:</span><br><span class="line">      - &quot;MYSQL_ROOT_PASSWORD&#x3D;root&quot;</span><br><span class="line">      #初始化的数据库名称</span><br><span class="line">      - &quot;MYSQL_DATABASE&#x3D;test_compose&quot;</span><br><span class="line">      - &quot;MYSQL_ROOT_HOST&#x3D;%&quot;</span><br><span class="line">    #容器名称</span><br><span class="line">    container_name: mysql-compose</span><br><span class="line">    restart: always</span><br><span class="line">    #数据卷映射关系，也就是把本地的目录，和mysql容器中的目录，进行对应映射。</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;.&#x2F;mysql&#x2F;data&#x2F;:&#x2F;var&#x2F;lib&#x2F;mysql&quot;</span><br><span class="line">      # - &quot;&#x2F;etc&#x2F;localtime:&#x2F;etc&#x2F;localtime&quot;</span><br><span class="line">    #该选项中的命令会覆盖Dockfile中的CMD中的命令.lower_case_table_names参数是为了表名不区分大小写，default-authentication-plugin是8.0中密码加密策略不同带来的链接问题，如果不用8.0可不加此选项</span><br><span class="line">    command: [</span><br><span class="line">          &#39;mysqld&#39;,</span><br><span class="line">          &#39;--innodb-buffer-pool-size&#x3D;20M&#39;,</span><br><span class="line">          &#39;--character-set-server&#x3D;utf8mb4&#39;,</span><br><span class="line">          &#39;--collation-server&#x3D;utf8mb4_bin&#39;,</span><br><span class="line">          &#39;--default-time-zone&#x3D;+8:00&#39;,</span><br><span class="line">          &#39;--lower-case-table-names&#x3D;1&#39;</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>
说明：</li>
</ol>
<p> 这里最重要的即为：–default-time-zone=+8:00，表示mysql本地时区加8小时，为东8区。</p>
]]></content>
      <categories>
        <category>docker容器</category>
      </categories>
      <tags>
        <tag>docker容器</tag>
      </tags>
  </entry>
  <entry>
    <title>GET和POST请求的区别</title>
    <url>/2021/01/14/get%E8%AF%B7%E6%B1%82%E5%92%8Cpost%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="关于http请求的get和post的区别"><a href="#关于http请求的get和post的区别" class="headerlink" title="关于http请求的get和post的区别"></a>关于http请求的get和post的区别</h1><p>在web开发的时候，我们一般都会使用ajax等技术直接访问后端的接口，这个时候，我们一般使用get或者post方法，今天来记录一下这两种方法的区别：</p>
<table>
<thead>
<tr>
<th align="center">区别类型</th>
<th align="center">get</th>
<th align="center">post</th>
</tr>
</thead>
<tbody><tr>
<td align="center">url可见性</td>
<td align="center">url可见</td>
<td align="center">url不可见</td>
</tr>
<tr>
<td align="center">数据传输性</td>
<td align="center">拼接url进行参数传递</td>
<td align="center">通过body体进行数据传输</td>
</tr>
<tr>
<td align="center">缓存性</td>
<td align="center">get可以缓存</td>
<td align="center">post不可缓存</td>
</tr>
<tr>
<td align="center">页面后退</td>
<td align="center">get不产生影响</td>
<td align="center">post提交新的请求</td>
</tr>
<tr>
<td align="center">传输数据大小</td>
<td align="center">get一般不超过2k-4k(根据浏览器和Web服务器限制)</td>
<td align="center">post方式理论上没有大小限制，取决于服务器</td>
</tr>
<tr>
<td align="center">安全性</td>
<td align="center">get数据直接暴露在请求地址上</td>
<td align="center">post请求地址不可看，有其他方式查看</td>
</tr>
<tr>
<td align="center">数据类型</td>
<td align="center">get只可以发送ASCII字符</td>
<td align="center">post可以发送更多</td>
</tr>
<tr>
<td align="center">操作目的</td>
<td align="center">get一般用于搜索和筛选之类的</td>
<td align="center">post主要用于修改和写入数据</td>
</tr>
<tr>
<td align="center">请求速度</td>
<td align="center">get较快</td>
<td align="center">post较慢：原因请查看下文</td>
</tr>
<tr>
<td align="center">能否管道化传输</td>
<td align="center">get可以</td>
<td align="center">post不可</td>
</tr>
</tbody></table>
<a id="more"></a>

<p>具体内容解释如下：</p>
<ol>
<li>请求速度：<br>get较快，因为post方式需要在请求的body包含部分数据，所以多了几个描述字段，如：Content-Type，但是，这不是最重要的，最重要的原因是：<strong>post请求在真正传送数据之前，会先将请求头发送到服务器进行确认</strong>，然后再发送数据。</li>
</ol>
<p>这样理解：<br>post请求的过程如下：</p>
<ol>
<li>浏览器请求tcp连接（第一次握手）</li>
<li>服务器答应进行tcp连接（第二次握手）</li>
<li>浏览器去人，并发送post请求头（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送）</li>
<li>服务器返回 100 Continue响应</li>
<li>浏览器发送数据</li>
<li>服务器返回 200 OK响应，或者返回其他响应。</li>
</ol>
<p>get请求的过程如下：</p>
<ol>
<li>浏览器请求tcp连接（第一次握手）</li>
<li>服务器答应进行tcp连接（第二次握手）</li>
<li>浏览器确认，并发送get请求头和数据（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送）</li>
<li>服务器返回 200 OK响应，或者返回其他响应。</li>
</ol>
]]></content>
      <categories>
        <category>网络请求</category>
      </categories>
      <tags>
        <tag>GET &amp;&amp; POST</tag>
      </tags>
  </entry>
  <entry>
    <title>hashCode和equals的区别</title>
    <url>/2021/07/13/hashCode%E5%92%8Cequals%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="Java-中-hashCode-和-equals-的作用，区别，联系？"><a href="#Java-中-hashCode-和-equals-的作用，区别，联系？" class="headerlink" title="Java 中 hashCode() 和 equals() 的作用，区别，联系？"></a>Java 中 hashCode() 和 equals() 的作用，区别，联系？</h1><p>记录一下在 Java 中，hashCode 和equals的区别：</p>
<h2 id="1-作用："><a href="#1-作用：" class="headerlink" title="1. 作用："></a>1. 作用：</h2><p>在 java 中都是用来对比两个对象是否相等以及是否一致。</p>
<h2 id="2-区别："><a href="#2-区别：" class="headerlink" title="2. 区别："></a>2. 区别：</h2><p>equals 默认调用的是 Object 类中的方法，主要判断的是对象的内存地址是否一致，也就是是否为同一个对象的地址。</p>
<p>重写的 equals 里一般比较得全面比较复杂，效率比较低；</p>
<p>但是利用了 hashCode 进行对比，只需要生成一个 hash 值比较就可以了，效率很高。但是 hashCode 并非完全可靠，存在 hash 冲突的问题 (此处类似于 java 集合中 Hashmap 的hash)；</p>
<p>注意点：</p>
<ul>
<li>equals() 中相等的两个对象，那么他们的 hashCode() 也是一定相等的，也就是用 equals() 对比是肯定可靠的。</li>
<li>如果两个对象的 hashCode一样，但是他们的 equals 不一定相等，也就是 hashCode 并非绝对可靠的。</li>
</ul>
<h2 id="3-关系："><a href="#3-关系：" class="headerlink" title="3. 关系："></a>3. 关系：</h2><blockquote>
<p> 重写 equals() 方法的时候，必须重写 hashCode() 方法</p>
</blockquote>
<ul>
<li>为了性能的考虑，首先使用 hashCode() 来判断是否相等。如果这两个不相等，则对象一定不同，如果相等，再使用 equals() 来对比。</li>
<li>为了保证是同一个对象，保证在 equals 相同的情况下 hashCode 值必定相同，如果重写了 equals 而未重写 hashCode，就可能出现两个无关对象的 equals 相同（equals 是通过对象的特征进行重写的），但是 hashCode不相同的情况。</li>
<li>hashCode 和 equals 都是基本类 Object 里的方法，和 equals 一样， Object 里 hashCode 只是返回当前对象的地址，如果是这样，相同一个类 new 两个对象，由于他们在内存的地址不同，则他们的 hashCode 不同，所以这显然不是我们想要的。所以我们必须重写类的 hashCode 方法，即，同一个类，在 hashCode 里面返回唯一的一个 hash 值。</li>
</ul>
]]></content>
      <categories>
        <category>hashcode</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka基本理解</title>
    <url>/2021/01/14/kafka%E6%9C%AF%E8%AF%AD%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="Kafka的基本属于理解"><a href="#Kafka的基本属于理解" class="headerlink" title="Kafka的基本属于理解"></a>Kafka的基本属于理解</h1><p>&emsp;最近在看kafka，对于kafka的使用，基本能够在官方的中文文档中得到一些基本的概念，但是对于kafka的一些基本术语的理解不够深刻，在百度上找寻了几篇文章，现在在这里留下自己关于kafka的理解。</p>
<p>kafka的基本术语有以下几个：</p>
<ul>
<li>broker</li>
<li>topic</li>
<li>stream</li>
<li>partition</li>
<li>offset</li>
<li>producer</li>
<li>consumer</li>
<li>consumer group</li>
</ul>
<p>稍后一个一个介绍上述术语，现在先来看一下kafka的工作流程：<br><br>&emsp;消息由producer进行产生，消息按照topic进行归类，并push(发送)到broker中，然后broker中保存了一个或者多个topic的消息，consumer通过订阅者模式，订阅一组topic消息，通过持续的pull进行消息的拉取，然后进行后续消息的处理。</p>
<a id="more"></a>

<ul>
<li><p>broker<br>&nbsp;一个kafka集群中包含了一个或者多个服务器，这些服务器称为broker，保存producer发送的消息。</p>
</li>
<li><p>topic<br>&nbsp;每条发送到broker的消息都有一个类别，这个类别称作为topic。</p>
</li>
<li><p>partition<br>&nbsp;一个topic的消息实际上是由多个队列进行存储的，一个队列在kafka上成为分区，即partition。</p>
</li>
<li><p>producer<br>&nbsp;负责发送指定的topic消息到broker，通俗的意思就是生产者。</p>
</li>
<li><p>consumer<br>&nbsp;消息读取的客户端，通过订阅一组topic的消息从broker拉取消息，也就是消费者。</p>
</li>
<li><p>consumer group<br>&nbsp;消费者组，一个消费者组是由一个或者多个consumer组成的，对于同一个topic，不同的消费者组都能将消费到全量的消息，而同一个消费者组中的consumer将竞争每个消息(在多个consumer消费同一个topic时，topic的任何一个分区将同时只能被一个consumer消费)。</p>
</li>
<li><p>offset<br>&nbsp;偏移量，kafka为每条消息在分区的消息保存一个偏移量offset，者也是消费者在分区的位置。比如一个偏移量是5的消费者，表示已经消费了从0-4偏移量的消息，下一个要消费的消息的偏移量是5。</p>
</li>
</ul>
<p>后续会继续更新关于kafka的使用，以及使用中遇到的问题~~~~~~~~~~~~</p>
]]></content>
      <categories>
        <category>消息中间件</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2021/03/13/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><blockquote>
<p>本篇学习整理，借鉴了博客<a href="https://blog.csdn.net/qq_34178598/article/details/78630934">https://blog.csdn.net/qq_34178598/article/details/78630934</a></p>
</blockquote>
<p>解析： <strong>一种为其他对象提供一种代理以控制这个对象的访问。</strong></p>
<p>主要存在以下两种类型：</p>
<ul>
<li>静态代理</li>
<li>动态代理</li>
</ul>
<p>主要作用：<strong>增强方法和权限拦截</strong></p>
<ol>
<li>静态代理：由程序员创建代理类，在程序运行前代理类的.class文件就已经存在了。</li>
<li>动态代理：程序运行期间通过反射机制动态创建而成。AOP就是用这个实现的</li>
</ol>
<blockquote>
<p>AOP就是基于动态代理实现的。</p>
</blockquote>
<a id="more"></a>

<h2 id="静态代理："><a href="#静态代理：" class="headerlink" title="静态代理："></a>静态代理：</h2><p> 静态代理举例：<strong>找房子</strong></p>
<p> 说明：你现在要去租房子，但是由于20年疫情的影响，导致你找不到个人房源，好的房子都在中介的手上，那么你只能通过中介来找房子，虽然最后是和房东签合同，但是你是通过了中介，这个中介就相当于起到了代理的作用。如下图：(图暂时没有)</p>
<p>你&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;中介&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;房东</p>
<p>上图所示：</p>
<p>你是调用类、中介是代理类、房东是被代理类。</p>
<p>这个时候中介在中间赚点money，起到增强方法的作用。</p>
<p>但是如果目标类很多方法，代理类也就需要有很多方法，很没有必要，所以只需要一些特定的代理方法即可，所以使用接口实现统一方法。</p>
<p>定义一个代理类和被代理类的接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface RentingService&#123;</span><br><span class="line">		&#x2F;&#x2F;租房方法</span><br><span class="line">		Integer rentingRoom();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>房东类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class LandLoard implements RentingService&#123;</span><br><span class="line">		</span><br><span class="line">		@Override</span><br><span class="line">		public Integer rentingRoom()&#123;</span><br><span class="line">			System.out.println(&quot;我要出租房子了,2000的套二，精装修。。。。。&quot;);</span><br><span class="line">			return 2000;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>中介类(代理类):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class IntermediaryProxy implements RentingService&#123;</span><br><span class="line">		</span><br><span class="line">		private LandLoard landLoard;</span><br><span class="line">		</span><br><span class="line">		@Override</span><br><span class="line">		public Integer rengingRoom()&#123;</span><br><span class="line">			if(landLoard &#x3D;&#x3D;  null)&#123;</span><br><span class="line">				landloard &#x3D; new LandLoard();</span><br><span class="line">			&#125;</span><br><span class="line">			Integer money &#x3D; landloard.rentingRoom();</span><br><span class="line">			return money + money;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用户类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User&#123;</span><br><span class="line">	public static void main(Striing[] args)&#123;</span><br><span class="line">		IntermediaryProxy intermediaryProxy &#x3D; new IntermediaryProxy();</span><br><span class="line">		Integer money &#x3D; intermediaryProxy.rentingRoom();</span><br><span class="line">		System.out.println(&quot;xxx先生您好，租房一共需要租金：&quot; + money + &quot;元&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>静态代理实例如上。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>先说静态代理缺点：因为代理对象需要和被代理对象实现一样的接口，所有会有很多代理类，类太多的同时，如果一旦接口增加方法，被代理对象和代理对象都需要维护。</p>
<p>为了解决这个缺点，就出现了动态代理，动态代理的好处，就是在代理的过程中，我们不需要手动编写代理类，在运行的时候，动态的在内存中产生代理类。(字节码对象级别的代理对象)。</p>
<p>动态代理实现的方式：</p>
<ul>
<li>jdk本身的动态代理方式。</li>
<li>cglib的动态代理方式。</li>
</ul>
<h3 id="jdk动态代理"><a href="#jdk动态代理" class="headerlink" title="jdk动态代理"></a>jdk动态代理</h3><p>在java.lang.reflect中有一个代理类Proxy</p>
<p>注意：如果使用jdk的动态代理，那么Proxy方式实现的目标对象，必须有接口，没有接口不能使用该方式实现动态代理。</p>
<p>统一接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface TragetInterface&#123;</span><br><span class="line">	void method1();</span><br><span class="line">	void method2();</span><br><span class="line">	int method3(Integer number);</span><br><span class="line">&#125;	</span><br></pre></td></tr></table></figure>
<p>目标类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Target implements TargetInterface&#123;</span><br><span class="line">	@Override</span><br><span class="line">    public void method1() &#123;</span><br><span class="line">        System.out.println(&quot;method1 running ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public void method2() &#123;</span><br><span class="line">        System.out.println(&quot;method2 running ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public int method3(Integer number) &#123;</span><br><span class="line">        System.out.println(&quot;method3 running ...&quot;);</span><br><span class="line">        return number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理工厂类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ProxyFactory &#123;</span><br><span class="line">    static &lt;T&gt; Object getProxy(T t)&#123;</span><br><span class="line">        &#x2F;&#x2F;返回一个代理对象</span><br><span class="line">        Object object &#x3D; Proxy.newProxyInstance(t.getClass().getClassLoader(), t.getClass().getInterfaces(), new InvocationHandler() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">                &#x2F;&#x2F; proxy就是目标对象，method就是调用目标对象中方法，args就是调用目标对象中方法的参数。</span><br><span class="line">                &#x2F;&#x2F;比如说：代理对象.method1(),这时proxy就是目标类，method1就是method,args就是method1方法参数。</span><br><span class="line">                System.out.println(&quot;执行方法前...&quot;);</span><br><span class="line">                Object invoke &#x3D; method.invoke(t, args);</span><br><span class="line">                System.out.println(&quot;执行方法后...&quot;);</span><br><span class="line">                return invoke;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用者类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">     public static void main(String[] args) &#123;</span><br><span class="line">        Target target &#x3D; new Target();</span><br><span class="line">        TargetInterface proxy &#x3D; (TargetInterface) ProxyFactory.getProxy(target);</span><br><span class="line">        proxy.method1();</span><br><span class="line">        System.out.println(&quot;-------------------------&quot;);</span><br><span class="line">        proxy.method2();</span><br><span class="line">        System.out.println(&quot;-------------------------&quot;);</span><br><span class="line">        int number &#x3D; proxy.method3(100);</span><br><span class="line">        System.out.println(number);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="cglib代理"><a href="#cglib代理" class="headerlink" title="cglib代理"></a>cglib代理</h3><p>cglib是一种第三方代理，原理是可以对目标对象的接口实现代理，也可以进行继承代理(不能对final修饰的代理继承)。需要引入cglib才行，spring本身自带了cglib，aop本身已经实现了cglib和jdk自带的代理了。</p>
<p>代码实现如下：</p>
<p>目标类：（可以不用实现接口，因为生成的代理类是目标类的子类）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Target &#123;</span><br><span class="line">    public void method1() &#123;</span><br><span class="line">        System.out.println(&quot;method1 running ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public void method2() &#123;</span><br><span class="line">        System.out.println(&quot;method2 running ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    public int method3(Integer i) &#123;</span><br><span class="line">        System.out.println(&quot;method3 running ...&quot;);</span><br><span class="line">        return i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CglibFactory类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CglibFactory &#123;</span><br><span class="line"> </span><br><span class="line">    static &lt;T&gt; Object getProxy(T t)&#123;</span><br><span class="line">        Enhancer en &#x3D; new Enhancer(); &#x2F;&#x2F;帮我们生成代理对象</span><br><span class="line">        en.setSuperclass(t.getClass());&#x2F;&#x2F;设置要代理的目标类</span><br><span class="line">        en.setCallback(new MethodInterceptor() &#123;&#x2F;&#x2F;代理要做什么</span><br><span class="line">            @Override</span><br><span class="line">            public Object intercept(Object object, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;</span><br><span class="line">                System.out.println(&quot;执行方法前。。。&quot;);</span><br><span class="line">                &#x2F;&#x2F;调用原有方法  </span><br><span class="line">                Object invoke &#x3D; methodProxy.invokeSuper(object, args);</span><br><span class="line">&#x2F;&#x2F;              Object invoke &#x3D; method.invoke(t,args); 作用等同与上面。</span><br><span class="line">                System.out.println(&quot;执行方法后。。。&quot;);</span><br><span class="line">                return invoke;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Object proxyObj &#x3D; en.create();&#x2F;&#x2F;生成代理对象</span><br><span class="line">        return proxyObj;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Created by Ming on 2017&#x2F;11&#x2F;25.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class User &#123;</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Target target &#x3D; new Target();</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">        TargetInterface proxy &#x3D; (TargetInterface) CglibFactory.getProxy(target);</span><br><span class="line"> </span><br><span class="line">        System.out.println(proxy.method3(100));</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：Spring AOP使用的就是动态代理。使用了jdk代理和cglib代理，比如Spring的事务也是使用的aop实现的，如果目标类没有实现接口的话，就会使用cglib代理。</p>
<p>总结：</p>
<ul>
<li>静态代理需要自己写代理类和目标方法</li>
<li>动态代理不需要自己实现代理类和目标方法，但是动态代理的目标类必须要实现接口。</li>
<li>cglib代理的目标类可以实现接口也可以不实现，因可以使用继承子类的方式代理。</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式-代理模式</tag>
      </tags>
  </entry>
  <entry>
    <title>http协议理解</title>
    <url>/2021/01/14/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE--http%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="一、Http协议介绍"><a href="#一、Http协议介绍" class="headerlink" title="一、Http协议介绍"></a>一、Http协议介绍</h1><h2 id="1-1-什么Http"><a href="#1-1-什么Http" class="headerlink" title="1.1 什么Http"></a>1.1 什么Http</h2><p>Http是<strong>超文本传输协议</strong>(Hyper Text Transfer Protocol)的缩写。<br>协议位于TCP/IP协议栈的应用层。<br><br></p>
<p>Http是一个客户端和服务器端请求和应答的标准，主要用于www(万维网)服务器传输超文本到本地浏览器之间的请求数据和响应数据的协议。客户端通过使用网页浏览器或者其他工具发起一个Http请求到服务器指定的端口:默认端口80，服务器接收到请求过后，返回响应内容(文本、图片等)。<br></p>
<p>Http协议是基于TCP协议来进行数据的传输的。</p>
<a id="more"></a>

<h2 id="1-2-Http的版本"><a href="#1-2-Http的版本" class="headerlink" title="1.2 Http的版本"></a>1.2 Http的版本</h2><p>Http协议已经演化出了很多版本，他们中的大部分都是向下兼容的。客户端在请求的开始告诉服务器它采用的协议版本号，然后后者则在响应中采用相同或者更加早的协议版本，现在大多都是1.1的版本。</p>
<ul>
<li><p><strong>1.0 版本</strong>： Http协议非常老的标准，为了提高系统的效率，Http1.0规定浏览器与服务器只需要保持短暂的连接，浏览器每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后，立即断开TCP连接，服务器不跟踪每个客户端也不记录每一个的请求。正是因为这种特性造成了一些性能上的缺陷。</p>
</li>
<li><p><strong>1.1 版本</strong>：克服了Http1.0的缺陷，Http 1.1支持持久连接(Http 1.1的默认模式是使用带流水线的持久连接)，在一个TCP连接上可以传送多个Http请求和响应，减少了建立和关闭连接的消耗和延迟。同时还增加更多的请求头和响应头来改进和扩充Http1.0的功能(比如POST请求头字段等)。</p>
</li>
<li><p><strong>2.0 版本</strong>：2015年5月作为互联网标准正式发布。主要新增的特性如下：多路复用，二进制分帧，首部压缩，服务端推送。</p>
</li>
</ul>
<h1 id="二、Http消息请求"><a href="#二、Http消息请求" class="headerlink" title="二、Http消息请求"></a>二、Http消息请求</h1><h2 id="2-1-URI、URL、URN"><a href="#2-1-URI、URL、URN" class="headerlink" title="2.1 URI、URL、URN"></a>2.1 URI、URL、URN</h2><p>通过Http或者HTTPS协议请求的资源由统一资源标识符(Uniform Resource Identifiers，URI)来标识。我们常用的是URL，对应的三者区别如下：</p>
<blockquote>
<p>URI = Uniform Resource Identifier   统一资源标识符<br><br>URL = Uniform Resource Locator      统一资源定位符<br><br>URN = Uniform Resource Name         统一资源名称</p>
</blockquote>
<p>三者关系如下：</p>
<ol>
<li>URI用唯一标识符来标识一个资源，是一个很通俗的概念，由URL和URN组成。</li>
<li>URL用来描述资源的位置来标识资源。</li>
<li>URN通过资源名字来标识资源，与其所在位置无关，这样即便资源的位置发生改变，URN也不会改变。</li>
</ol>
<h2 id="2-2-消息请求格式"><a href="#2-2-消息请求格式" class="headerlink" title="2.2 消息请求格式"></a>2.2 消息请求格式</h2><p>Http的消息请求主要包含以下三个部分：</p>
<ul>
<li>请求行</li>
<li>请求头</li>
<li>数据体</li>
</ul>
<p>分别对这三个类型进行解释：</p>
<h3 id="2-2-1-请求行"><a href="#2-2-1-请求行" class="headerlink" title="2.2.1 请求行"></a>2.2.1 请求行</h3><p>请求行包含了三个内容：method + request-Url + http-version</p>
<ol>
<li>method主要有以下方法：<br></li>
</ol>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">方法描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">get</td>
<td align="center">通过请求URI获得资源</td>
</tr>
<tr>
<td align="center">post</td>
<td align="center">用于添加新的资源，用于表单提交</td>
</tr>
<tr>
<td align="center">put</td>
<td align="center">用于修改某个内容</td>
</tr>
<tr>
<td align="center">delete</td>
<td align="center">删除某个内容</td>
</tr>
<tr>
<td align="center">connect</td>
<td align="center">用于代理进行传输例如SSL</td>
</tr>
<tr>
<td align="center">options</td>
<td align="center">询问可以执行那些方法</td>
</tr>
<tr>
<td align="center">patch</td>
<td align="center">部分文档更该</td>
</tr>
<tr>
<td align="center">propfind</td>
<td align="center">查看属性</td>
</tr>
<tr>
<td align="center">proppatch</td>
<td align="center">设置属性</td>
</tr>
<tr>
<td align="center">mkcol</td>
<td align="center">创建集合</td>
</tr>
<tr>
<td align="center">copy</td>
<td align="center">拷贝</td>
</tr>
<tr>
<td align="center">move</td>
<td align="center">移动</td>
</tr>
<tr>
<td align="center">lock</td>
<td align="center">加锁</td>
</tr>
<tr>
<td align="center">unlock</td>
<td align="center">解锁</td>
</tr>
<tr>
<td align="center">trace</td>
<td align="center">用于远程诊断服务器</td>
</tr>
<tr>
<td align="center">head</td>
<td align="center">类似于get，用于检查对象是否存在用于得到元数据</td>
</tr>
</tbody></table>
<p>常见的网站开发中，都基本会使用get或者post方法，这两个区别，也是一些面试需要了解的，详情请了解以下文章：</p>
<h3 id="2-2-2-请求头"><a href="#2-2-2-请求头" class="headerlink" title="2.2.2 请求头"></a>2.2.2 请求头</h3><p>请求头主要包含以下内容：</p>
<ol>
<li>Accept：值浏览器或者其他客户端可以接收到额MiMe文件格式。servlet可以根据它判断并返回适当的文件格式。</li>
<li>User-Agent：是客户端浏览器名称。</li>
<li>Host：对应翁罗URL中的Web名称和端口号。</li>
<li>Accept-Langueage：指出浏览器可以接受的语言种类，如en或者en-us(英语)。</li>
<li>connection：用来告诉服务器是否可以维持固定的Http连接，Http是无连接的，Http 1.1使用Keep-Alive为默认值，这样，当浏览器需要多个文件时(比如一个Html文件和相关的图形文件)，不需要每次都建立连接。</li>
<li>Cookie：浏览器用这个属性向服务器发送Cookie。Cookie是在浏览器中积存的小型数据体，它可以记载和服务器相关的用户信息，也可以用来实现会话功能。</li>
<li>Referer：表明产生请求的网页URL。如从网页/gitee.io/index.jsp中点击了一个连接到网页/gitee.io/search，在向服务器发送的get /gitee.io/search 中的请求中，Referer是<a href="http://hostname:8080/gitee.io/index.jsp%E3%80%82">http://hostname:8080/gitee.io/index.jsp。</a> 这个属性可以用来跟踪web请求是从什么网站来的。</li>
<li>User-Agent：是用户浏览器的名称。</li>
<li>Content-Type：用来表明request的内容类型。可以ongoingHTTPServletRequest的getContentType()方法取到。<strong>post才有，get方式为空</strong>。</li>
<li>Accept-Charset：支出浏览器可以接受的字符编码。英文浏览器的默认值是ISO-8859-1。</li>
<li>Accept-Encoding：指出浏览器可以接受的编码方式。编码方式不同于文件格式，它是为了压缩文件并加速文件传递速度。浏览器在接收到Web响应之后先解码，然后再检查文件格式。<br>
post请求专属：</li>
<li>Content-Length：表示post的数据的长度。</li>
</ol>
<h2 id="2-3-数据体"><a href="#2-3-数据体" class="headerlink" title="2.3 数据体"></a>2.3 数据体</h2><p>主要就是请求参数的内容。例如：<br>username=ceshi&amp;password=1234.</p>
<h1 id="三、Http消息响应"><a href="#三、Http消息响应" class="headerlink" title="三、Http消息响应"></a>三、Http消息响应</h1><p>Http响应由三个部分组成：状态行、响应头、响应正文</p>
<p>状态行是由Http-Verion + Status-Code + Reason-Phrase</p>
<p>比如：HTTP/1.1 200 ok<br>分别表示为：http版本 + 状态吗 + 状态码描述</p>
<p>状态码和对应描述如下：</p>
<table>
<thead>
<tr>
<th align="center">状态码</th>
<th align="left">状态码描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1xx</td>
<td align="left">指示信息–表示请求已接收，继续处理</td>
</tr>
<tr>
<td align="center">2xx</td>
<td align="left">成功–表示请求已被成功接收、理解、接受</td>
</tr>
<tr>
<td align="center">3xx</td>
<td align="left">重定向–要完成请求必须进行更进一步的操作。</td>
</tr>
<tr>
<td align="center">4xx</td>
<td align="left">客户端错误–请求有语法错误或请求无法实现。</td>
</tr>
<tr>
<td align="center">5xx</td>
<td align="left">服务器端错误–服务器未能实现合法的请求。</td>
</tr>
</tbody></table>
<p>最常见的状态码如下：</p>
<table>
<thead>
<tr>
<th align="center">状态码</th>
<th align="center">英文描述</th>
<th align="left">中文描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">200</td>
<td align="center">OK</td>
<td align="left">客户端请求成功</td>
</tr>
<tr>
<td align="center">400</td>
<td align="center">Bad Request</td>
<td align="left">客户端请求有语法错误，不能被服务器所理解</td>
</tr>
<tr>
<td align="center">401</td>
<td align="center">Unauthorized</td>
<td align="left">请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</td>
</tr>
<tr>
<td align="center">403</td>
<td align="center">Forbidden</td>
<td align="left">服务器收到请求，但是拒绝提供服务</td>
</tr>
<tr>
<td align="center">404</td>
<td align="center">Not Found</td>
<td align="left">请求资源不存在，比如：输入了错误的URL</td>
</tr>
<tr>
<td align="center">500</td>
<td align="center">Internal Server Error</td>
<td align="left">服务器发生不可预期的错误</td>
</tr>
<tr>
<td align="center">503</td>
<td align="center">Server Unavailable</td>
<td align="left">由于超载或系统维护，服务器暂时的无法处理客户端的请求</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络-http</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式id策略</title>
    <url>/2021/01/14/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%8B-%E7%94%9F%E6%88%90%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8FID/</url>
    <content><![CDATA[<h1 id="springboot中-全局ID的生成-分布式ID"><a href="#springboot中-全局ID的生成-分布式ID" class="headerlink" title="springboot中-全局ID的生成(分布式ID)"></a>springboot中-全局ID的生成(分布式ID)</h1><h3 id="一、背景知识"><a href="#一、背景知识" class="headerlink" title="一、背景知识"></a>一、背景知识</h3><p>在分布式系统中，经常需要对大量的数据，消息，http请求等进行唯一的标识。<br>常见的，就是在springcloud中，对请求路径进行记录，一般使用链路分析的时候，必须要对请求，使用唯一标识，这个时候如果直接使用数据库自增的id，不能满足实际情况，这个时候，只能使用生成唯一ID的系统，该系统必须满足以下的要求：<br></p>
<ul>
<li>全局唯一性：不能出现重复的ID。</li>
<li>高可用：ID生成系统是基础系统，被许多关键系统调用，如果GG(宕机)，会很被锤。</li>
</ul>
<h4 id="经典方案："><a href="#经典方案：" class="headerlink" title="经典方案："></a>经典方案：</h4><ul>
<li>使用UUID</li>
<li>使用数据库自增ID</li>
<li>使用redis的incr命令生成(本文不讲述)</li>
<li>使用Twitter的snowflake(雪花)算法</li>
<li>利用zookeeper生成唯一ID</li>
<li>MongoDB的ObjectId<br></li>
</ul>
<a id="more"></a>

<h4 id="经典方案实现"><a href="#经典方案实现" class="headerlink" title="经典方案实现"></a>经典方案实现</h4><h4 id="1-UUID"><a href="#1-UUID" class="headerlink" title="1. UUID"></a>1. UUID</h4><p><br>&emsp;UUID是在一定范围内唯一的机器生成的标识符，UUID一般是生成32位或者36位，唯一局别是是否存在对应-号。<br><br>&emsp;UUID生成规则为：网卡MAC地址+时间戳+名字空间+随机或者伪随机数+时序等元素，UUID的复杂性，保证了它的唯一性，意味着只能由计算机生成。<br><br></p>
<h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul>
<li>本地生成ID，不需要远程调用，延迟低，性能很高。<br></li>
</ul>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>UUID过程，很多场景，例如数据库索引字段，很不适合。</li>
<li>没有排序，没办法趋势的递增。</li>
</ul>
<h4 id="2-使用数据库自增ID"><a href="#2-使用数据库自增ID" class="headerlink" title="2. 使用数据库自增ID"></a>2. 使用数据库自增ID</h4><p><br>&emsp;例如：使用mysql的自增主键id。<br><br></p>
<h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h5><ul>
<li>充分借助了数据库的自增ID机制，可靠性高，生成有序的ID。</li>
</ul>
<br>
##### 缺点：
- ID生成性能依赖单台数据库读写性能
- 依赖数据库，当数据库GG，全部都不可用。


<h4 id="3-使用雪花算法生成"><a href="#3-使用雪花算法生成" class="headerlink" title="3. 使用雪花算法生成"></a>3. 使用雪花算法生成</h4><p><br>&emsp; 这种方案生成一个64bit的数字，这个数字被分成多个段，分别表示时间戳、机器编码、序号。<br><br><br><br><img src="http://www.dubby.cn/upload/1508161671799snowflake-64bit.jpg" alt="雪花算法" title="雪花算法"></p>
<h5 id="ID为64bit-的long-数字，由三部分组成："><a href="#ID为64bit-的long-数字，由三部分组成：" class="headerlink" title="ID为64bit 的long 数字，由三部分组成："></a>ID为64bit 的long 数字，由三部分组成：</h5><ul>
<li>41位的时间序列(精确到毫秒，41位的长度可以使用69年)。</li>
<li>10位的机器标识(10位的长度最多支持部署1024个节点)。</li>
<li>12位的计数顺序号(12位的计数顺序号支持每个节点每毫秒产生4096个ID序号)。</li>
</ul>
<br>
##### 优点:
- 时间戳在高位，自增序列在低位，整个ID是趋势递增的，按照时间有序。
- 性能高，每秒可生成几百万ID。
- 可以根据自身业务需求灵活调整bit位划分，满足不同需求。

<h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>依赖机器时钟，如果机器时钟回拨，会导致重复ID生成。</li>
<li>在单机上是递增的，但是由于涉及到分布式环境，每台机器上的时钟不可能完全同步，有时候会出现不是全局递增的情况。</li>
</ul>
<h4 id="4-利用zookeeper生成唯一ID"><a href="#4-利用zookeeper生成唯一ID" class="headerlink" title="4. 利用zookeeper生成唯一ID"></a>4. 利用zookeeper生成唯一ID</h4><p>代码如下：</p>
<ul>
<li><p>引入依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.zookeeper&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;zookeeper&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;3.4.12&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.apache.curator&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;curator-framework&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;2.8.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.apache.curator&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;curator-recipes&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;2.8.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure></li>
<li><p>编写代码</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.sopp.learning;</span><br><span class="line"></span><br><span class="line">import org.apache.curator.RetryPolicy;</span><br><span class="line">import org.apache.curator.framework.CuratorFramework;</span><br><span class="line">import org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line">import org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class="line">import org.apache.zookeeper.CreateMode;</span><br><span class="line">import org.apache.zookeeper.data.Stat;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class DistributedIdGeneraterService &#123;</span><br><span class="line"></span><br><span class="line">    private static CuratorFramework curatorFrameworkClient;</span><br><span class="line"></span><br><span class="line">    private static RetryPolicy retryPolicy;</span><br><span class="line"></span><br><span class="line">    private static ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">    private static String IP_TOSTRING &#x3D; &quot;10.200.121.46:2181,10.200.121.43:2181,10.200.121.167:2181&quot;;</span><br><span class="line"></span><br><span class="line">    private static String ROOT &#x3D; &quot;&#x2F;root&quot;;</span><br><span class="line"></span><br><span class="line">    private static String NODE_NAME &#x3D; &quot;idgenerator&quot;;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        retryPolicy &#x3D; new ExponentialBackoffRetry(1000, 3);</span><br><span class="line">        curatorFrameworkClient &#x3D; CuratorFrameworkFactory</span><br><span class="line">                .builder()</span><br><span class="line">                .connectString(IP_TOSTRING)</span><br><span class="line">                .sessionTimeoutMs(5000)</span><br><span class="line">                .connectionTimeoutMs(5000)</span><br><span class="line">                .retryPolicy(retryPolicy)</span><br><span class="line">                .build();</span><br><span class="line">        curatorFrameworkClient.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            executorService &#x3D; Executors.newFixedThreadPool(10);</span><br><span class="line">            &#x2F;&#x2F;请先判断父节点&#x2F;root节点是否存在</span><br><span class="line">            Stat stat &#x3D; curatorFrameworkClient.checkExists().forPath(ROOT);</span><br><span class="line">            if (stat &#x3D;&#x3D; null) &#123;</span><br><span class="line">                curatorFrameworkClient.create().withMode(CreateMode.PERSISTENT).forPath(ROOT, null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String generateId() &#123;</span><br><span class="line">        String backPath &#x3D; &quot;&quot;;</span><br><span class="line"></span><br><span class="line">        String fullPath &#x3D; ROOT.concat(&quot;&#x2F;&quot;).concat(NODE_NAME);</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 关键点：创建持久顺序节点</span><br><span class="line">            backPath &#x3D; curatorFrameworkClient.create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath(fullPath, null);</span><br><span class="line">            &#x2F;&#x2F;为防止生成的节点浪费系统资源，故生成后异步删除此节点</span><br><span class="line">            String finalBackPath &#x3D; backPath;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    curatorFrameworkClient.delete().forPath(finalBackPath);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            String ID &#x3D; this.splitID(backPath);</span><br><span class="line">            System.out.println(&quot;生成的ID&#x3D;&quot; + ID);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return backPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String splitID(String path) &#123;</span><br><span class="line">        int index &#x3D; path.lastIndexOf(NODE_NAME);</span><br><span class="line">        if (index &gt;&#x3D; 0) &#123;</span><br><span class="line">            index +&#x3D; NODE_NAME.length();</span><br><span class="line">            return index &lt;&#x3D; path.length() ? path.substring(index) : &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5-使用MongoDB实现分布式ID"><a href="#5-使用MongoDB实现分布式ID" class="headerlink" title="5.使用MongoDB实现分布式ID"></a>5.使用MongoDB实现分布式ID</h4><br>
MongoDB的ObjectId设计成轻量型的，不同的机器，都可以用全局唯一的同种方法方便的生成它。MongoDB从一开始就设计用来作为分布式数据库，处理多个节点是一个核心的要求。使其在分片环境中要容易生成得多。<br>
##### 原理：
格式如下：<br>

<p><img src="http://upload-images.jianshu.io/upload_images/2279594-fa59770ee4c176cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="ObjectId" title="ObjectId"></p>
<ul>
<li><p>前4 个字节是从标准纪元开始的时间戳，单位为秒。时间戳，与随后的5 个字节组合起来，提供了秒级别的唯一性。由于时间戳在前，这意味着ObjectId 大致会按照插入的顺序排列。这对于某些方面很有用，如将其作为索引提高效率。这4 个字节也隐含了文档创建的时间。绝大多数客户端类库都会公开一个方法从ObjectId 获取这个信息。</p>
</li>
<li><p>接下来的3 字节是所在主机的唯一标识符。通常是机器主机名的散列值。这样就可以确保不同主机生成不同的ObjectId，不产生冲突。为了确保在同一台机器上并发的多个进程产生的ObjectId 是唯一的，接下来的两字节来自产生ObjectId 的进程标识符（PID）。</p>
</li>
<li><p>前9 字节保证了同一秒钟不同机器不同进程产生的ObjectId 是唯一的。</p>
</li>
<li><p>后3 字节就是一个自动增加的计数器，确保相同进程同一秒产生的ObjectId 也是不一样的。同一秒钟最多允许每个进程拥有2563（16 777 216）个不同的ObjectId。</p>
</li>
</ul>
<h5 id="编码："><a href="#编码：" class="headerlink" title="编码："></a>编码：</h5><ul>
<li>在springboot中引入MongoDB：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!--mvc--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--lombok--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--mongodb --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个实体类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.cetc.entity;</span><br><span class="line"></span><br><span class="line">import lombok.Data;</span><br><span class="line">import org.springframework.data.annotation.Id;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @ClassName: Customer</span><br><span class="line"> * @Description: TODO</span><br><span class="line"> * @Author: Sopp</span><br><span class="line"> * @Date: 2019&#x2F;4&#x2F;26 10:38</span><br><span class="line"> **&#x2F;</span><br><span class="line">@Data</span><br><span class="line">public class Customer &#123;</span><br><span class="line">    @Id</span><br><span class="line">    public String id;</span><br><span class="line"></span><br><span class="line">    public String firstName;</span><br><span class="line">    public String lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建mongodb接口类：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.cetc.dao;</span><br><span class="line"></span><br><span class="line">import com.cetc.entity.Customer;</span><br><span class="line">import org.springframework.data.mongodb.repository.MongoRepository;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @ClassName: CustomerRepository</span><br><span class="line"> * @Description: TODO</span><br><span class="line"> * @Author: Sopp</span><br><span class="line"> * @Date: 2019&#x2F;4&#x2F;26 10:39</span><br><span class="line"> **&#x2F;</span><br><span class="line">public interface CustomerRepository extends MongoRepository&lt;Customer, String&gt; &#123;</span><br><span class="line">    public Customer findByFirstName(String firstName);</span><br><span class="line"></span><br><span class="line">    public List&lt;Customer&gt; findByLastName(String lastName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建测试类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import com.cetc.dao.CustomerRepository;</span><br><span class="line">import com.cetc.entity.Customer;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @ClassName: TestMongodb</span><br><span class="line"> * @Description: TODO</span><br><span class="line"> * @Author: Sopp</span><br><span class="line"> * @Date: 2019&#x2F;4&#x2F;26 10:40</span><br><span class="line"> **&#x2F;</span><br><span class="line">@Slf4j</span><br><span class="line">public class TestMongodb &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    CustomerRepository customerRepository;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void mongodbIdTest() &#123;</span><br><span class="line">        Customer customer &#x3D; new Customer(&quot;lxdxil&quot;, &quot;dd&quot;);</span><br><span class="line">        customer &#x3D; customerRepository.save(customer);</span><br><span class="line">        log.info(&quot;mongodbId:&quot; + customer.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式id</tag>
      </tags>
  </entry>
  <entry>
    <title>多线程基本学习</title>
    <url>/2021/03/13/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0-%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC/</url>
    <content><![CDATA[<h1 id="多线程学习-线程基本"><a href="#多线程学习-线程基本" class="headerlink" title="多线程学习-线程基本"></a>多线程学习-线程基本</h1><ol>
<li><h2 id="线程有哪些实现方式？"><a href="#线程有哪些实现方式？" class="headerlink" title="线程有哪些实现方式？"></a>线程有哪些实现方式？</h2><p>常见的线程有哪些实现方式？分别来看下：</p>
<p>先来看看两种实现方式的代码：</p>
<h4 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableThread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;用实现Runnable接口实现多线程&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式确实可以实现多线程，只需要实现Ruunable接口，重写run方法，然后把这个实现了run方法的实例传递到Thread类中即可实现多线程。</p>
<h4 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;通过继承Thread类实现多线程&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="线程池创建线程"><a href="#线程池创建线程" class="headerlink" title="线程池创建线程"></a>线程池创建线程</h4><p>为什么还有第三种或者第四种创建线程的方式呢？先看下第三种方式：通过创建线程池来创建线程，但是我们还是来看下线程池是如何实现线程创建的呢？</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static class DefaultThreadFactory implements ThreadFactory &#123;</span><br><span class="line">  </span><br><span class="line">    DefaultThreadFactory() &#123;</span><br><span class="line">        SecurityManager s &#x3D; System.getSecurityManager();</span><br><span class="line">        group &#x3D; (s !&#x3D; null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();</span><br><span class="line">        namePrefix &#x3D; &quot;pool-&quot; + poolNumber.getAndIncrement() + &quot;-thread-&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Thread newThread(Runnable r) &#123;</span><br><span class="line">        Thread t &#x3D; new Thread(group, r,namePrefix + threadNumber.getAndIncrement(),0);</span><br><span class="line">        if (t.isDaemon())&#123;</span><br><span class="line">          t.setDaemon(false);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        if (t.getPriority() !&#x3D; Thread.NORM_PRIORITY)&#123;</span><br><span class="line">          t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于线程池来说，本质来说是通过线程工厂来创建线程的，默认采用的是 DefaultThreadFactory ，它会给线程池创建的线程设置一些默认值，比如：线程的</p>
<p>名字、线程是否守护线程、以及线程的优先级等。但是无论怎么设置，最后都是通过new Thread() 来创建的，只不过传参更多了一点而已。</p>
<h4 id="有返回值的Callable创建线程"><a href="#有返回值的Callable创建线程" class="headerlink" title="有返回值的Callable创建线程"></a>有返回值的Callable创建线程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class CallableTask implements Callable&lt;Integer&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Integer call() throws Exception &#123;</span><br><span class="line">        return new Random().nextInt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;创建线程池</span><br><span class="line">ExecutorService service &#x3D; Executors.newFixedThreadPool(10);</span><br><span class="line">&#x2F;&#x2F;提交任务，并用 Future提交返回结果</span><br><span class="line">Future&lt;Integer&gt; future &#x3D; service.submit(new CallableTask());</span><br><span class="line"></span><br><span class="line">System.out.println(future.get());</span><br></pre></td></tr></table></figure>
<p>第 4 种线程创建方式是通过有返回值的 Callable 创建线程，Runnable 创建线程是无返回值的，而 Callable 和与之相关的 Future、FutureTask，它们可以把</p>
<p>线程执行的结果作为返回值返回，如代码所示，实现了 Callable 接口，并且给它的泛型设置成 Integer，然后它会返回一个随机数。</p>
<p>但是，无论是 Callable 还是 FutureTask，它们首先和 Runnable 一样，都是一个任务，是需要被执行的，而不是说它们本身就是线程。它们可以放到线程池</p>
<p>中执行，如代码所示， submit() 方法把任务放到线程池中，并由线程池创建线程，不管用什么方法，最终都是靠线程来执行的，而子线程的创建方式仍脱离不</p>
<p>了最开始讲的两种基本方式，也就是实现 Runnable 接口和继承 Thread 类。</p>
<h3 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h3><h4 id="定时器Timer"><a href="#定时器Timer" class="headerlink" title="定时器Timer"></a>定时器Timer</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class TimerThread extends Thread &#123;</span><br><span class="line">	&#x2F;&#x2F;具体实现</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果新建一个 Timer，令其每隔 10 秒或设置两个小时之后，执行一些任务，那么这时它确实也创建了线程并执行了任务，但如果我们深入分析定时器的源码</p>
<p>会发现，本质上它还是会有一个继承自 Thread 类的 TimerThread，所以定时器创建线程最后又绕回到最开始说的两种方式。</p>
<h3 id="实现线程只有一种方式"><a href="#实现线程只有一种方式" class="headerlink" title="实现线程只有一种方式"></a>实现线程只有一种方式</h3><p>事实上创建线程只有一种方式，就是<strong>构造一个Thread类</strong>，这是创建线程的唯一方式。</p>
<h3 id="实现Runnable接口比继承Thread类实现线程要好"><a href="#实现Runnable接口比继承Thread类实现线程要好" class="headerlink" title="实现Runnable接口比继承Thread类实现线程要好"></a>实现Runnable接口比继承Thread类实现线程要好</h3><p>使用Runnable接口实现线程比Thread类好的原因如下：</p>
<ul>
<li>解耦，Runnable中的run放啊，定义需要执行的内容，Thread类负责线程启动和属性设置，权责分明，解耦。</li>
<li>提高性能，使用Thread类，如果只是打印一个小内容，都需要线程创建与销毁，非常耗费性能，但是如果使用Runnable方式，就直接传递对应对象到线程池中，需要就执行，不需要就归还给线程池，不用销毁。</li>
<li>继承并不方便扩展。</li>
</ul>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>线程基本</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/2021/01/14/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF~~~~/</url>
    <content><![CDATA[<h1 id="关于红黑树的那点事儿"><a href="#关于红黑树的那点事儿" class="headerlink" title="关于红黑树的那点事儿"></a>关于红黑树的那点事儿</h1><blockquote>
<p>本文参考于<a href="http://www.360doc.com/content/18/0904/19/25944647_783893127.shtml">http://www.360doc.com/content/18/0904/19/25944647_783893127.shtml</a></p>
</blockquote>
<p>&emsp;关于红黑树，我们可能是即熟悉又陌生，在大学的几年撸代码生涯中，老师或多或少会讲述关于红黑树的问题，<br>但是一般只有当我们面试的时候，或者校招的时候，才会花时间去了解和复习什么是红黑树。今天来记录一下，自己关于红黑树的复习与理解。</p>
<p>  &emsp;在进入红黑树的学习之前，必须要了解一个东西，叫做-二叉查找树(BST)<br></p>
<p>  &emsp;二叉查找树的特性如下：</p>
<ul>
<li>左子树上所有的节点的值均小于或等于他的根节点的值。</li>
<li>右子数上所有的节点的值均大于或等于他的根节点的值。</li>
<li>左右子树也一定分别为二叉排序树。</li>
</ul>
<a id="more"></a>

<p>  以下为一颗二叉查找树：</p>
<p>  <img src="/2021/01/14/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF~~~~/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91.png" alt="二叉查找树"></p>
<p>&emsp;为什么一定要有这种结构呢？这种结构的好处在哪里呢？<br>接下来我们来查找一下值为10这个节点的数据，看一下具体的步骤是怎样的：<br><br></p>
<ol>
<li>查找跟节点9，如图所示：</li>
</ol>
<p>  <img src="/2021/01/14/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF~~~~/%E8%8A%82%E7%82%B99.png" alt="节点9"></p>
<ol start="2">
<li>由于查找的节点值为10,10大于根节点9，那么久表示需要查询右边孩子节点13，如图：</li>
</ol>
<p>  <img src="/2021/01/14/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF~~~~/%E8%8A%82%E7%82%B913.png" alt="节点13"></p>
<ol start="3">
<li>由于查询的值10 &lt; 13，那么久查询左孩子节点11：如图：</li>
</ol>
<p>  <img src="/2021/01/14/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF~~~~/%E8%8A%82%E7%82%B911.png" alt="节点11"></p>
<ol start="4">
<li>由于查询的值10 &lt; 11,那么查询左节点10，最终查询到10这个节点值，如图：</li>
</ol>
<p>  <img src="/2021/01/14/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF~~~~/%E8%8A%82%E7%82%B910.png" alt="节点10"></p>
<p>经历了以上4步操作，最终查找到了节点数据为10的子节点。<br>以上的操作，是参照了二分查找的思想</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>红黑树-算法</tag>
      </tags>
  </entry>
</search>
