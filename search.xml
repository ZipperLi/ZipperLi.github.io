<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>TCP/IP的理解</title>
    <url>/sopp.github.io/2021/01/14/TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="对于TCP-IP的理解"><a href="#对于TCP-IP的理解" class="headerlink" title="对于TCP/IP的理解"></a>对于TCP/IP的理解</h1><p>&emsp;在很多人面试的时候，都遇见过招聘要求上要求这一项</p>
<blockquote>
<p>精通TCP/IP，熟练使用Socket进行网络编程。</p>
</blockquote>
<p>看到这句话，贼提莫熟悉，很多人都觉得这些东西，在我们实际的开发中遇不到，楼主在很早之前也是一样的想法，但是越工作，就越来越觉得这些知识很重要。<br>下面我们就来了解以下什么是TCP/IP。</p>
<h2 id="一、什么是TCP-IP"><a href="#一、什么是TCP-IP" class="headerlink" title="一、什么是TCP/IP"></a>一、什么是TCP/IP</h2><p>tcp/ip是一类协议系统，它是用于网络通信的一套协议的集合。<br>传统的tcp/ip被认为是一个四层的协议系统。</p>
<table>
  <tr>
    <th>OSI体系结构</th>
    <th colspan="2">TCP/IP协议集合</th>
  </tr>

  <tr>
    <td>应用层</td>
    <td rowspan="3">应用层</td>
    <td rowspan="3">TELNET、FTP、HTTP、SMTP、DNS等</td>
  </tr>
  <tr>
    <td>表示层</td>
  </tr>
  <tr>
    <td>会话层</td>
  </tr>

  <tr>
    <td>传输层</td>
    <td>传输层</td>
    <td>TCP、UDP</td>
  </tr>
  <tr>
    <td>网络层</td>
    <td>网络层</td>
    <td>IP、ICMP、ARP、RARP</td>
  </tr>
  <tr>
    <td>数据链路层</td>
    <td rowspan="2">网络层</td>
    <td rowspan="2">各种物理通信网络接口</td>
  </tr>
  <tr>
    <td>物理层</td>
  </tr>
</table>

<p>对应体系结构解释：</p>
<a id="more"></a>

<h3 id="1-1-网络接口层"><a href="#1-1-网络接口层" class="headerlink" title="1.1 网络接口层"></a>1.1 网络接口层</h3><p>主要是值物理层次的一些接口，比如电缆等。</p>
<h3 id="1-2-网络层"><a href="#1-2-网络层" class="headerlink" title="1.2 网络层"></a>1.2 网络层</h3><p>提供独立于硬件的逻辑寻址，实现物理地址与逻辑地址的转换。<br>在TCP/IP协议族中，网络层协议包括IP协议(网际协议)，ICMP协议(Internet互联网控制报文协议)，以及IGMP协议(Internet组管理协议)。</p>
<h3 id="1-3-传输层"><a href="#1-3-传输层" class="headerlink" title="1.3 传输层"></a>1.3 传输层</h3><p>为网络层提供了流量控制，错误控制和确认服务。<br>在TCP/IP协议族中，由两个互不相同的传输协议：TCP(传输控制协议)和UDP(用户数据报协议)。</p>
<h3 id="1-4-应用层"><a href="#1-4-应用层" class="headerlink" title="1.4 应用层"></a>1.4 应用层</h3><p>为网络拍错，文件传输，远程控制和Internet操作提供具体的应用程序。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
      </tags>
  </entry>
  <entry>
    <title>docker容器mysql时间不同步</title>
    <url>/sopp.github.io/2021/01/14/docker%E5%AE%B9%E5%99%A8mysql%E6%97%B6%E9%97%B4%E4%B8%8D%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="docker容器mysql时间不同步问题"><a href="#docker容器mysql时间不同步问题" class="headerlink" title="docker容器mysql时间不同步问题"></a>docker容器mysql时间不同步问题</h1><p>最近由于项目中需要进行时间同步，刚好项目中需要使用到docker，所以从docker方面入手进行时间同步。</p>
<blockquote>
<p>每日一点学习，加油~</p>
</blockquote>
<ol>
<li>首先进行容器和主机的时间同步。<br>在docker-compose的配置文件中，使用/etc/localtime:/etc/localtime参数进行容器时间同步。具体的示例如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql:</span><br><span class="line">    build:</span><br><span class="line">      #dockerfile的路径</span><br><span class="line">      context: .&#x2F;mysql</span><br><span class="line">      #dockerfile的名称</span><br><span class="line">      dockerfile: Dockerfile</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;3307:3306&quot;</span><br><span class="line">    #相当于docker run命令中的-e</span><br><span class="line">    environment:</span><br><span class="line">      - &quot;MYSQL_ROOT_PASSWORD&#x3D;root&quot;</span><br><span class="line">      #初始化的数据库名称</span><br><span class="line">      - &quot;MYSQL_DATABASE&#x3D;test_compose&quot;</span><br><span class="line">      - &quot;MYSQL_ROOT_HOST&#x3D;%&quot;</span><br><span class="line">    #容器名称</span><br><span class="line">    container_name: mysql-compose</span><br><span class="line">    restart: always</span><br><span class="line">    #数据卷映射关系，也就是把本地的目录，和mysql容器中的目录，进行对应映射。</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;.&#x2F;mysql&#x2F;data&#x2F;:&#x2F;var&#x2F;lib&#x2F;mysql&quot;</span><br><span class="line">      - &quot;&#x2F;etc&#x2F;localtime:&#x2F;etc&#x2F;localtime&quot;</span><br></pre></td></tr></table></figure>
说明：<br>这里最重要的即为 /etc/localtime:/etc/localtime，使用这个配置，对docker容器和外部主机的时间进行同步。</li>
</ol>
<a id="more"></a>

<ol start="2">
<li>如果容器中存在mysql等，那么即需要同步mysql的时间与mysql容器的时间。一般默认为配置mysql默认时区即可。具体示例如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql:</span><br><span class="line">    build:</span><br><span class="line">      #dockerfile的路径</span><br><span class="line">      context: .&#x2F;mysql</span><br><span class="line">      #dockerfile的名称</span><br><span class="line">      dockerfile: Dockerfile</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;3307:3306&quot;</span><br><span class="line">    #相当于docker run命令中的-e</span><br><span class="line">    environment:</span><br><span class="line">      - &quot;MYSQL_ROOT_PASSWORD&#x3D;root&quot;</span><br><span class="line">      #初始化的数据库名称</span><br><span class="line">      - &quot;MYSQL_DATABASE&#x3D;test_compose&quot;</span><br><span class="line">      - &quot;MYSQL_ROOT_HOST&#x3D;%&quot;</span><br><span class="line">    #容器名称</span><br><span class="line">    container_name: mysql-compose</span><br><span class="line">    restart: always</span><br><span class="line">    #数据卷映射关系，也就是把本地的目录，和mysql容器中的目录，进行对应映射。</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;.&#x2F;mysql&#x2F;data&#x2F;:&#x2F;var&#x2F;lib&#x2F;mysql&quot;</span><br><span class="line">      # - &quot;&#x2F;etc&#x2F;localtime:&#x2F;etc&#x2F;localtime&quot;</span><br><span class="line">    #该选项中的命令会覆盖Dockfile中的CMD中的命令.lower_case_table_names参数是为了表名不区分大小写，default-authentication-plugin是8.0中密码加密策略不同带来的链接问题，如果不用8.0可不加此选项</span><br><span class="line">    command: [</span><br><span class="line">          &#39;mysqld&#39;,</span><br><span class="line">          &#39;--innodb-buffer-pool-size&#x3D;20M&#39;,</span><br><span class="line">          &#39;--character-set-server&#x3D;utf8mb4&#39;,</span><br><span class="line">          &#39;--collation-server&#x3D;utf8mb4_bin&#39;,</span><br><span class="line">          &#39;--default-time-zone&#x3D;+8:00&#39;,</span><br><span class="line">          &#39;--lower-case-table-names&#x3D;1&#39;</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>
说明：</li>
</ol>
<p> 这里最重要的即为：–default-time-zone=+8:00，表示mysql本地时区加8小时，为东8区。</p>
]]></content>
      <categories>
        <category>docker容器</category>
      </categories>
      <tags>
        <tag>docker容器</tag>
      </tags>
  </entry>
  <entry>
    <title>GET和POST请求的区别</title>
    <url>/sopp.github.io/2021/01/14/get%E8%AF%B7%E6%B1%82%E5%92%8Cpost%E8%AF%B7%E6%B1%82%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h1 id="关于http请求的get和post的区别"><a href="#关于http请求的get和post的区别" class="headerlink" title="关于http请求的get和post的区别"></a>关于http请求的get和post的区别</h1><p>在web开发的时候，我们一般都会使用ajax等技术直接访问后端的接口，这个时候，我们一般使用get或者post方法，今天来记录一下这两种方法的区别：</p>
<table>
<thead>
<tr>
<th align="center">区别类型</th>
<th align="center">get</th>
<th align="center">post</th>
</tr>
</thead>
<tbody><tr>
<td align="center">url可见性</td>
<td align="center">url可见</td>
<td align="center">url不可见</td>
</tr>
<tr>
<td align="center">数据传输性</td>
<td align="center">拼接url进行参数传递</td>
<td align="center">通过body体进行数据传输</td>
</tr>
<tr>
<td align="center">缓存性</td>
<td align="center">get可以缓存</td>
<td align="center">post不可缓存</td>
</tr>
<tr>
<td align="center">页面后退</td>
<td align="center">get不产生影响</td>
<td align="center">post提交新的请求</td>
</tr>
<tr>
<td align="center">传输数据大小</td>
<td align="center">get一般不超过2k-4k(根据浏览器和Web服务器限制)</td>
<td align="center">post方式理论上没有大小限制，取决于服务器</td>
</tr>
<tr>
<td align="center">安全性</td>
<td align="center">get数据直接暴露在请求地址上</td>
<td align="center">post请求地址不可看，有其他方式查看</td>
</tr>
<tr>
<td align="center">数据类型</td>
<td align="center">get只可以发送ASCII字符</td>
<td align="center">post可以发送更多</td>
</tr>
<tr>
<td align="center">操作目的</td>
<td align="center">get一般用于搜索和筛选之类的</td>
<td align="center">post主要用于修改和写入数据</td>
</tr>
<tr>
<td align="center">请求速度</td>
<td align="center">get较快</td>
<td align="center">post较慢：原因请查看下文</td>
</tr>
<tr>
<td align="center">能否管道化传输</td>
<td align="center">get可以</td>
<td align="center">post不可</td>
</tr>
</tbody></table>
<p>具体内容解释如下：</p>
<ol>
<li>请求速度：<br>get较快，因为post方式需要在请求的body包含部分数据，所以多了几个描述字段，如：Content-Type，但是，这不是最重要的，最重要的原因是：<strong>post请求在真正传送数据之前，会先将请求头发送到服务器进行确认</strong>，然后再发送数据。</li>
</ol>
<p>这样理解：</p>
<a id="more"></a>

<p>post请求的过程如下：</p>
<ol>
<li>浏览器请求tcp连接（第一次握手）</li>
<li>服务器答应进行tcp连接（第二次握手）</li>
<li>浏览器去人，并发送post请求头（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送）</li>
<li>服务器返回 100 Continue响应</li>
<li>浏览器发送数据</li>
<li>服务器返回 200 OK响应，或者返回其他响应。</li>
</ol>
<p>get请求的过程如下：</p>
<ol>
<li>浏览器请求tcp连接（第一次握手）</li>
<li>服务器答应进行tcp连接（第二次握手）</li>
<li>浏览器确认，并发送get请求头和数据（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送）</li>
<li>服务器返回 200 OK响应，或者返回其他响应。</li>
</ol>
]]></content>
      <categories>
        <category>网络请求</category>
      </categories>
      <tags>
        <tag>GET &amp;&amp; POST</tag>
      </tags>
  </entry>
  <entry>
    <title>kafka基本理解</title>
    <url>/sopp.github.io/2021/01/14/kafka%E6%9C%AF%E8%AF%AD%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="Kafka的基本属于理解"><a href="#Kafka的基本属于理解" class="headerlink" title="Kafka的基本属于理解"></a>Kafka的基本属于理解</h1><p>&emsp;最近在看kafka，对于kafka的使用，基本能够在官方的中文文档中得到一些基本的概念，但是对于kafka的一些基本术语的理解不够深刻，在百度上找寻了几篇文章，现在在这里留下自己关于kafka的理解。</p>
<p>kafka的基本术语有以下几个：</p>
<ul>
<li>broker</li>
<li>topic</li>
<li>stream</li>
<li>partition</li>
<li>offset</li>
<li>producer</li>
<li>consumer</li>
<li>consumer group</li>
</ul>
<p>稍后一个一个介绍上述术语，现在先来看一下kafka的工作流程：<br><br>&emsp;消息由producer进行产生，消息按照topic进行归类，并push(发送)到broker中，然后broker中保存了一个或者多个topic的消息，consumer通过订阅者模式，订阅一组topic消息，通过持续的pull进行消息的拉取，然后进行后续消息的处理。</p>
<a id="more"></a>

<ul>
<li><p>broker<br>&nbsp;一个kafka集群中包含了一个或者多个服务器，这些服务器称为broker，保存producer发送的消息。</p>
</li>
<li><p>topic<br>&nbsp;每条发送到broker的消息都有一个类别，这个类别称作为topic。</p>
</li>
<li><p>partition<br>&nbsp;一个topic的消息实际上是由多个队列进行存储的，一个队列在kafka上成为分区，即partition。</p>
</li>
<li><p>producer<br>&nbsp;负责发送指定的topic消息到broker，通俗的意思就是生产者。</p>
</li>
<li><p>consumer<br>&nbsp;消息读取的客户端，通过订阅一组topic的消息从broker拉取消息，也就是消费者。</p>
</li>
<li><p>consumer group<br>&nbsp;消费者组，一个消费者组是由一个或者多个consumer组成的，对于同一个topic，不同的消费者组都能将消费到全量的消息，而同一个消费者组中的consumer将竞争每个消息(在多个consumer消费同一个topic时，topic的任何一个分区将同时只能被一个consumer消费)。</p>
</li>
<li><p>offset<br>&nbsp;偏移量，kafka为每条消息在分区的消息保存一个偏移量offset，者也是消费者在分区的位置。比如一个偏移量是5的消费者，表示已经消费了从0-4偏移量的消息，下一个要消费的消息的偏移量是5。</p>
</li>
</ul>
<p>后续会继续更新关于kafka的使用，以及使用中遇到的问题~~~~~~~~~~~~</p>
]]></content>
      <categories>
        <category>消息中间件</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>http协议理解</title>
    <url>/sopp.github.io/2021/01/14/%E5%85%B3%E4%BA%8E%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE--http%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="一、Http协议介绍"><a href="#一、Http协议介绍" class="headerlink" title="一、Http协议介绍"></a>一、Http协议介绍</h1><h2 id="1-1-什么Http"><a href="#1-1-什么Http" class="headerlink" title="1.1 什么Http"></a>1.1 什么Http</h2><p>Http是<strong>超文本传输协议</strong>(Hyper Text Transfer Protocol)的缩写。<br>协议位于TCP/IP协议栈的应用层。<br><br></p>
<p>Http是一个客户端和服务器端请求和应答的标准，主要用于www(万维网)服务器传输超文本到本地浏览器之间的请求数据和响应数据的协议。客户端通过使用网页浏览器或者其他工具发起一个Http请求到服务器指定的端口:默认端口80，服务器接收到请求过后，返回响应内容(文本、图片等)。<br></p>
<p>Http协议是基于TCP协议来进行数据的传输的。</p>
<h2 id="1-2-Http的版本"><a href="#1-2-Http的版本" class="headerlink" title="1.2 Http的版本"></a>1.2 Http的版本</h2><p>Http协议已经演化出了很多版本，他们中的大部分都是向下兼容的。客户端在请求的开始告诉服务器它采用的协议版本号，然后后者则在响应中采用相同或者更加早的协议版本，现在大多都是1.1的版本。</p>
<ul>
<li><p><strong>1.0 版本</strong>： Http协议非常老的标准，为了提高系统的效率，Http1.0规定浏览器与服务器只需要保持短暂的连接，浏览器每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后，立即断开TCP连接，服务器不跟踪每个客户端也不记录每一个的请求。正是因为这种特性造成了一些性能上的缺陷。</p>
</li>
<li><p><strong>1.1 版本</strong>：克服了Http1.0的缺陷，Http 1.1支持持久连接(Http 1.1的默认模式是使用带流水线的持久连接)，在一个TCP连接上可以传送多个Http请求和响应，减少了建立和关闭连接的消耗和延迟。同时还增加更多的请求头和响应头来改进和扩充Http1.0的功能(比如POST请求头字段等)。</p>
</li>
<li><p><strong>2.0 版本</strong>：2015年5月作为互联网标准正式发布。主要新增的特性如下：多路复用，二进制分帧，首部压缩，服务端推送。</p>
</li>
</ul>
<h1 id="二、Http消息请求"><a href="#二、Http消息请求" class="headerlink" title="二、Http消息请求"></a>二、Http消息请求</h1><h2 id="2-1-URI、URL、URN"><a href="#2-1-URI、URL、URN" class="headerlink" title="2.1 URI、URL、URN"></a>2.1 URI、URL、URN</h2><p>通过Http或者HTTPS协议请求的资源由统一资源标识符(Uniform Resource Identifiers，URI)来标识。我们常用的是URL，对应的三者区别如下：</p>
<blockquote>
<p>URI = Uniform Resource Identifier   统一资源标识符<br><br>URL = Uniform Resource Locator      统一资源定位符<br><br>URN = Uniform Resource Name         统一资源名称</p>
</blockquote>
<p>三者关系如下：</p>
<ol>
<li>URI用唯一标识符来标识一个资源，是一个很通俗的概念，由URL和URN组成。</li>
<li>URL用来描述资源的位置来标识资源。</li>
<li>URN通过资源名字来标识资源，与其所在位置无关，这样即便资源的位置发生改变，URN也不会改变。</li>
</ol>
<a id="more"></a>

<h2 id="2-2-消息请求格式"><a href="#2-2-消息请求格式" class="headerlink" title="2.2 消息请求格式"></a>2.2 消息请求格式</h2><p>Http的消息请求主要包含以下三个部分：</p>
<ul>
<li>请求行</li>
<li>请求头</li>
<li>数据体</li>
</ul>
<p>分别对这三个类型进行解释：</p>
<h3 id="2-2-1-请求行"><a href="#2-2-1-请求行" class="headerlink" title="2.2.1 请求行"></a>2.2.1 请求行</h3><p>请求行包含了三个内容：method + request-Url + http-version</p>
<ol>
<li>method主要有以下方法：<br></li>
</ol>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">方法描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">get</td>
<td align="center">通过请求URI获得资源</td>
</tr>
<tr>
<td align="center">post</td>
<td align="center">用于添加新的资源，用于表单提交</td>
</tr>
<tr>
<td align="center">put</td>
<td align="center">用于修改某个内容</td>
</tr>
<tr>
<td align="center">delete</td>
<td align="center">删除某个内容</td>
</tr>
<tr>
<td align="center">connect</td>
<td align="center">用于代理进行传输例如SSL</td>
</tr>
<tr>
<td align="center">options</td>
<td align="center">询问可以执行那些方法</td>
</tr>
<tr>
<td align="center">patch</td>
<td align="center">部分文档更该</td>
</tr>
<tr>
<td align="center">propfind</td>
<td align="center">查看属性</td>
</tr>
<tr>
<td align="center">proppatch</td>
<td align="center">设置属性</td>
</tr>
<tr>
<td align="center">mkcol</td>
<td align="center">创建集合</td>
</tr>
<tr>
<td align="center">copy</td>
<td align="center">拷贝</td>
</tr>
<tr>
<td align="center">move</td>
<td align="center">移动</td>
</tr>
<tr>
<td align="center">lock</td>
<td align="center">加锁</td>
</tr>
<tr>
<td align="center">unlock</td>
<td align="center">解锁</td>
</tr>
<tr>
<td align="center">trace</td>
<td align="center">用于远程诊断服务器</td>
</tr>
<tr>
<td align="center">head</td>
<td align="center">类似于get，用于检查对象是否存在用于得到元数据</td>
</tr>
</tbody></table>
<p>常见的网站开发中，都基本会使用get或者post方法，这两个区别，也是一些面试需要了解的，详情请了解以下文章：</p>
<h3 id="2-2-2-请求头"><a href="#2-2-2-请求头" class="headerlink" title="2.2.2 请求头"></a>2.2.2 请求头</h3><p>请求头主要包含以下内容：</p>
<ol>
<li>Accept：值浏览器或者其他客户端可以接收到额MiMe文件格式。servlet可以根据它判断并返回适当的文件格式。</li>
<li>User-Agent：是客户端浏览器名称。</li>
<li>Host：对应翁罗URL中的Web名称和端口号。</li>
<li>Accept-Langueage：指出浏览器可以接受的语言种类，如en或者en-us(英语)。</li>
<li>connection：用来告诉服务器是否可以维持固定的Http连接，Http是无连接的，Http 1.1使用Keep-Alive为默认值，这样，当浏览器需要多个文件时(比如一个Html文件和相关的图形文件)，不需要每次都建立连接。</li>
<li>Cookie：浏览器用这个属性向服务器发送Cookie。Cookie是在浏览器中积存的小型数据体，它可以记载和服务器相关的用户信息，也可以用来实现会话功能。</li>
<li>Referer：表明产生请求的网页URL。如从网页/gitee.io/index.jsp中点击了一个连接到网页/gitee.io/search，在向服务器发送的get /gitee.io/search 中的请求中，Referer是<a href="http://hostname:8080/gitee.io/index.jsp%E3%80%82">http://hostname:8080/gitee.io/index.jsp。</a> 这个属性可以用来跟踪web请求是从什么网站来的。</li>
<li>User-Agent：是用户浏览器的名称。</li>
<li>Content-Type：用来表明request的内容类型。可以ongoingHTTPServletRequest的getContentType()方法取到。<strong>post才有，get方式为空</strong>。</li>
<li>Accept-Charset：支出浏览器可以接受的字符编码。英文浏览器的默认值是ISO-8859-1。</li>
<li>Accept-Encoding：指出浏览器可以接受的编码方式。编码方式不同于文件格式，它是为了压缩文件并加速文件传递速度。浏览器在接收到Web响应之后先解码，然后再检查文件格式。<br>
post请求专属：</li>
<li>Content-Length：表示post的数据的长度。</li>
</ol>
<h2 id="2-3-数据体"><a href="#2-3-数据体" class="headerlink" title="2.3 数据体"></a>2.3 数据体</h2><p>主要就是请求参数的内容。例如：<br>username=ceshi&amp;password=1234.</p>
<h1 id="三、Http消息响应"><a href="#三、Http消息响应" class="headerlink" title="三、Http消息响应"></a>三、Http消息响应</h1><p>Http响应由三个部分组成：状态行、响应头、响应正文</p>
<p>状态行是由Http-Verion + Status-Code + Reason-Phrase</p>
<p>比如：HTTP/1.1 200 ok<br>分别表示为：http版本 + 状态吗 + 状态码描述</p>
<p>状态码和对应描述如下：</p>
<table>
<thead>
<tr>
<th align="center">状态码</th>
<th align="left">状态码描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1xx</td>
<td align="left">指示信息–表示请求已接收，继续处理</td>
</tr>
<tr>
<td align="center">2xx</td>
<td align="left">成功–表示请求已被成功接收、理解、接受</td>
</tr>
<tr>
<td align="center">3xx</td>
<td align="left">重定向–要完成请求必须进行更进一步的操作。</td>
</tr>
<tr>
<td align="center">4xx</td>
<td align="left">客户端错误–请求有语法错误或请求无法实现。</td>
</tr>
<tr>
<td align="center">5xx</td>
<td align="left">服务器端错误–服务器未能实现合法的请求。</td>
</tr>
</tbody></table>
<p>最常见的状态码如下：</p>
<table>
<thead>
<tr>
<th align="center">状态码</th>
<th align="center">英文描述</th>
<th align="left">中文描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">200</td>
<td align="center">OK</td>
<td align="left">客户端请求成功</td>
</tr>
<tr>
<td align="center">400</td>
<td align="center">Bad Request</td>
<td align="left">客户端请求有语法错误，不能被服务器所理解</td>
</tr>
<tr>
<td align="center">401</td>
<td align="center">Unauthorized</td>
<td align="left">请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用</td>
</tr>
<tr>
<td align="center">403</td>
<td align="center">Forbidden</td>
<td align="left">服务器收到请求，但是拒绝提供服务</td>
</tr>
<tr>
<td align="center">404</td>
<td align="center">Not Found</td>
<td align="left">请求资源不存在，比如：输入了错误的URL</td>
</tr>
<tr>
<td align="center">500</td>
<td align="center">Internal Server Error</td>
<td align="left">服务器发生不可预期的错误</td>
</tr>
<tr>
<td align="center">503</td>
<td align="center">Server Unavailable</td>
<td align="left">由于超载或系统维护，服务器暂时的无法处理客户端的请求</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络-http</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式id策略</title>
    <url>/sopp.github.io/2021/01/14/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%8B-%E7%94%9F%E6%88%90%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8FID/</url>
    <content><![CDATA[<h1 id="springboot中-全局ID的生成-分布式ID"><a href="#springboot中-全局ID的生成-分布式ID" class="headerlink" title="springboot中-全局ID的生成(分布式ID)"></a>springboot中-全局ID的生成(分布式ID)</h1><h3 id="一、背景知识"><a href="#一、背景知识" class="headerlink" title="一、背景知识"></a>一、背景知识</h3><p>在分布式系统中，经常需要对大量的数据，消息，http请求等进行唯一的标识。<br>常见的，就是在springcloud中，对请求路径进行记录，一般使用链路分析的时候，必须要对请求，使用唯一标识，这个时候如果直接使用数据库自增的id，不能满足实际情况，这个时候，只能使用生成唯一ID的系统，该系统必须满足以下的要求：<br></p>
<ul>
<li>全局唯一性：不能出现重复的ID。</li>
<li>高可用：ID生成系统是基础系统，被许多关键系统调用，如果GG(宕机)，会很被锤。</li>
</ul>
<h4 id="经典方案："><a href="#经典方案：" class="headerlink" title="经典方案："></a>经典方案：</h4><ul>
<li>使用UUID</li>
<li>使用数据库自增ID</li>
<li>使用redis的incr命令生成(本文不讲述)</li>
<li>使用Twitter的snowflake(雪花)算法</li>
<li>利用zookeeper生成唯一ID</li>
<li>MongoDB的ObjectId<br>

</li>
</ul>
<h4 id="经典方案实现"><a href="#经典方案实现" class="headerlink" title="经典方案实现"></a>经典方案实现</h4><h4 id="1-UUID"><a href="#1-UUID" class="headerlink" title="1. UUID"></a>1. UUID</h4><p><br>&emsp;UUID是在一定范围内唯一的机器生成的标识符，UUID一般是生成32位或者36位，唯一局别是是否存在对应-号。<br><br>&emsp;UUID生成规则为：网卡MAC地址+时间戳+名字空间+随机或者伪随机数+时序等元素，UUID的复杂性，保证了它的唯一性，意味着只能由计算机生成。<br><br></p>
<h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul>
<li>本地生成ID，不需要远程调用，延迟低，性能很高。<br>

</li>
</ul>
<h5 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>UUID过程，很多场景，例如数据库索引字段，很不适合。</li>
<li>没有排序，没办法趋势的递增。</li>
</ul>
<h4 id="2-使用数据库自增ID"><a href="#2-使用数据库自增ID" class="headerlink" title="2. 使用数据库自增ID"></a>2. 使用数据库自增ID</h4><p><br>&emsp;例如：使用mysql的自增主键id。<br><br></p>
<h5 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h5><ul>
<li>充分借助了数据库的自增ID机制，可靠性高，生成有序的ID。</li>
</ul>
<br>
##### 缺点：
- ID生成性能依赖单台数据库读写性能
- 依赖数据库，当数据库GG，全部都不可用。


<h4 id="3-使用雪花算法生成"><a href="#3-使用雪花算法生成" class="headerlink" title="3. 使用雪花算法生成"></a>3. 使用雪花算法生成</h4><p><br>&emsp; 这种方案生成一个64bit的数字，这个数字被分成多个段，分别表示时间戳、机器编码、序号。<br><br><br><br><img src="http://www.dubby.cn/upload/1508161671799snowflake-64bit.jpg" alt="雪花算法" title="雪花算法"></p>
<h5 id="ID为64bit-的long-数字，由三部分组成："><a href="#ID为64bit-的long-数字，由三部分组成：" class="headerlink" title="ID为64bit 的long 数字，由三部分组成："></a>ID为64bit 的long 数字，由三部分组成：</h5><ul>
<li>41位的时间序列(精确到毫秒，41位的长度可以使用69年)。</li>
<li>10位的机器标识(10位的长度最多支持部署1024个节点)。</li>
<li>12位的计数顺序号(12位的计数顺序号支持每个节点每毫秒产生4096个ID序号)。</li>
</ul>
<br />
##### 优点:
- 时间戳在高位，自增序列在低位，整个ID是趋势递增的，按照时间有序。
- 性能高，每秒可生成几百万ID。
- 可以根据自身业务需求灵活调整bit位划分，满足不同需求。

<h5 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h5><ul>
<li>依赖机器时钟，如果机器时钟回拨，会导致重复ID生成。</li>
<li>在单机上是递增的，但是由于涉及到分布式环境，每台机器上的时钟不可能完全同步，有时候会出现不是全局递增的情况。</li>
</ul>
<a id="more"></a>

<h4 id="4-利用zookeeper生成唯一ID"><a href="#4-利用zookeeper生成唯一ID" class="headerlink" title="4. 利用zookeeper生成唯一ID"></a>4. 利用zookeeper生成唯一ID</h4><p>代码如下：</p>
<ul>
<li><p>引入依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.zookeeper&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;zookeeper&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;3.4.12&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.apache.curator&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;curator-framework&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;2.8.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.apache.curator&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;curator-recipes&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;2.8.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写代码</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.sopp.learning;</span><br><span class="line"></span><br><span class="line">import org.apache.curator.RetryPolicy;</span><br><span class="line">import org.apache.curator.framework.CuratorFramework;</span><br><span class="line">import org.apache.curator.framework.CuratorFrameworkFactory;</span><br><span class="line">import org.apache.curator.retry.ExponentialBackoffRetry;</span><br><span class="line">import org.apache.zookeeper.CreateMode;</span><br><span class="line">import org.apache.zookeeper.data.Stat;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import java.util.concurrent.ExecutorService;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class DistributedIdGeneraterService &#123;</span><br><span class="line"></span><br><span class="line">    private static CuratorFramework curatorFrameworkClient;</span><br><span class="line"></span><br><span class="line">    private static RetryPolicy retryPolicy;</span><br><span class="line"></span><br><span class="line">    private static ExecutorService executorService;</span><br><span class="line"></span><br><span class="line">    private static String IP_TOSTRING &#x3D; &quot;10.200.121.46:2181,10.200.121.43:2181,10.200.121.167:2181&quot;;</span><br><span class="line"></span><br><span class="line">    private static String ROOT &#x3D; &quot;&#x2F;root&quot;;</span><br><span class="line"></span><br><span class="line">    private static String NODE_NAME &#x3D; &quot;idgenerator&quot;;</span><br><span class="line"></span><br><span class="line">    static &#123;</span><br><span class="line">        retryPolicy &#x3D; new ExponentialBackoffRetry(1000, 3);</span><br><span class="line">        curatorFrameworkClient &#x3D; CuratorFrameworkFactory</span><br><span class="line">                .builder()</span><br><span class="line">                .connectString(IP_TOSTRING)</span><br><span class="line">                .sessionTimeoutMs(5000)</span><br><span class="line">                .connectionTimeoutMs(5000)</span><br><span class="line">                .retryPolicy(retryPolicy)</span><br><span class="line">                .build();</span><br><span class="line">        curatorFrameworkClient.start();</span><br><span class="line">        try &#123;</span><br><span class="line">            executorService &#x3D; Executors.newFixedThreadPool(10);</span><br><span class="line">            &#x2F;&#x2F;请先判断父节点&#x2F;root节点是否存在</span><br><span class="line">            Stat stat &#x3D; curatorFrameworkClient.checkExists().forPath(ROOT);</span><br><span class="line">            if (stat &#x3D;&#x3D; null) &#123;</span><br><span class="line">                curatorFrameworkClient.create().withMode(CreateMode.PERSISTENT).forPath(ROOT, null);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String generateId() &#123;</span><br><span class="line">        String backPath &#x3D; &quot;&quot;;</span><br><span class="line"></span><br><span class="line">        String fullPath &#x3D; ROOT.concat(&quot;&#x2F;&quot;).concat(NODE_NAME);</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 关键点：创建持久顺序节点</span><br><span class="line">            backPath &#x3D; curatorFrameworkClient.create().withMode(CreateMode.PERSISTENT_SEQUENTIAL).forPath(fullPath, null);</span><br><span class="line">            &#x2F;&#x2F;为防止生成的节点浪费系统资源，故生成后异步删除此节点</span><br><span class="line">            String finalBackPath &#x3D; backPath;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    curatorFrameworkClient.delete().forPath(finalBackPath);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            String ID &#x3D; this.splitID(backPath);</span><br><span class="line">            System.out.println(&quot;生成的ID&#x3D;&quot; + ID);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return backPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String splitID(String path) &#123;</span><br><span class="line">        int index &#x3D; path.lastIndexOf(NODE_NAME);</span><br><span class="line">        if (index &gt;&#x3D; 0) &#123;</span><br><span class="line">            index +&#x3D; NODE_NAME.length();</span><br><span class="line">            return index &lt;&#x3D; path.length() ? path.substring(index) : &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        return path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="5-使用MongoDB实现分布式ID"><a href="#5-使用MongoDB实现分布式ID" class="headerlink" title="5.使用MongoDB实现分布式ID"></a>5.使用MongoDB实现分布式ID</h4><br>
MongoDB的ObjectId设计成轻量型的，不同的机器，都可以用全局唯一的同种方法方便的生成它。MongoDB从一开始就设计用来作为分布式数据库，处理多个节点是一个核心的要求。使其在分片环境中要容易生成得多。<br>
##### 原理：
格式如下：<br>

<p><img src="http://upload-images.jianshu.io/upload_images/2279594-fa59770ee4c176cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="ObjectId" title="ObjectId"></p>
<ul>
<li><p>前4 个字节是从标准纪元开始的时间戳，单位为秒。时间戳，与随后的5 个字节组合起来，提供了秒级别的唯一性。由于时间戳在前，这意味着ObjectId 大致会按照插入的顺序排列。这对于某些方面很有用，如将其作为索引提高效率。这4 个字节也隐含了文档创建的时间。绝大多数客户端类库都会公开一个方法从ObjectId 获取这个信息。</p>
</li>
<li><p>接下来的3 字节是所在主机的唯一标识符。通常是机器主机名的散列值。这样就可以确保不同主机生成不同的ObjectId，不产生冲突。为了确保在同一台机器上并发的多个进程产生的ObjectId 是唯一的，接下来的两字节来自产生ObjectId 的进程标识符（PID）。</p>
</li>
<li><p>前9 字节保证了同一秒钟不同机器不同进程产生的ObjectId 是唯一的。</p>
</li>
<li><p>后3 字节就是一个自动增加的计数器，确保相同进程同一秒产生的ObjectId 也是不一样的。同一秒钟最多允许每个进程拥有2563（16 777 216）个不同的ObjectId。</p>
</li>
</ul>
<h5 id="编码："><a href="#编码：" class="headerlink" title="编码："></a>编码：</h5><ul>
<li>在springboot中引入MongoDB：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;!--mvc--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--lombok--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">        &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--mongodb --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建一个实体类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.cetc.entity;</span><br><span class="line"></span><br><span class="line">import lombok.Data;</span><br><span class="line">import org.springframework.data.annotation.Id;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @ClassName: Customer</span><br><span class="line"> * @Description: TODO</span><br><span class="line"> * @Author: Sopp</span><br><span class="line"> * @Date: 2019&#x2F;4&#x2F;26 10:38</span><br><span class="line"> **&#x2F;</span><br><span class="line">@Data</span><br><span class="line">public class Customer &#123;</span><br><span class="line">    @Id</span><br><span class="line">    public String id;</span><br><span class="line"></span><br><span class="line">    public String firstName;</span><br><span class="line">    public String lastName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建mongodb接口类：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.cetc.dao;</span><br><span class="line"></span><br><span class="line">import com.cetc.entity.Customer;</span><br><span class="line">import org.springframework.data.mongodb.repository.MongoRepository;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @ClassName: CustomerRepository</span><br><span class="line"> * @Description: TODO</span><br><span class="line"> * @Author: Sopp</span><br><span class="line"> * @Date: 2019&#x2F;4&#x2F;26 10:39</span><br><span class="line"> **&#x2F;</span><br><span class="line">public interface CustomerRepository extends MongoRepository&lt;Customer, String&gt; &#123;</span><br><span class="line">    public Customer findByFirstName(String firstName);</span><br><span class="line"></span><br><span class="line">    public List&lt;Customer&gt; findByLastName(String lastName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>创建测试类</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import com.cetc.dao.CustomerRepository;</span><br><span class="line">import com.cetc.entity.Customer;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @ClassName: TestMongodb</span><br><span class="line"> * @Description: TODO</span><br><span class="line"> * @Author: Sopp</span><br><span class="line"> * @Date: 2019&#x2F;4&#x2F;26 10:40</span><br><span class="line"> **&#x2F;</span><br><span class="line">@Slf4j</span><br><span class="line">public class TestMongodb &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    CustomerRepository customerRepository;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void mongodbIdTest() &#123;</span><br><span class="line">        Customer customer &#x3D; new Customer(&quot;lxdxil&quot;, &quot;dd&quot;);</span><br><span class="line">        customer &#x3D; customerRepository.save(customer);</span><br><span class="line">        log.info(&quot;mongodbId:&quot; + customer.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式id</tag>
      </tags>
  </entry>
  <entry>
    <title>红黑树</title>
    <url>/sopp.github.io/2021/01/14/%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E9%82%A3%E7%82%B9%E4%BA%8B%E5%84%BF~~~~/</url>
    <content><![CDATA[<h1 id="关于红黑树的那点事儿"><a href="#关于红黑树的那点事儿" class="headerlink" title="关于红黑树的那点事儿"></a>关于红黑树的那点事儿</h1><blockquote>
<p>本文参考于<a href="http://www.360doc.com/content/18/0904/19/25944647_783893127.shtml">http://www.360doc.com/content/18/0904/19/25944647_783893127.shtml</a></p>
</blockquote>
<p>&emsp;关于红黑树，我们可能是即熟悉又陌生，在大学的几年撸代码生涯中，老师或多或少会讲述关于红黑树的问题，<br>但是一般只有当我们面试的时候，或者校招的时候，才会花时间去了解和复习什么是红黑树。今天来记录一下，自己关于红黑树的复习与理解。</p>
<p>  &emsp;在进入红黑树的学习之前，必须要了解一个东西，叫做-二叉查找树(BST)<br></p>
<p>  &emsp;二叉查找树的特性如下：</p>
<ul>
<li><p>左子树上所有的节点的值均小于或等于他的根节点的值。</p>
</li>
<li><p>右子数上所有的节点的值均大于或等于他的根节点的值。</p>
</li>
<li><p>左右子树也一定分别为二叉排序树。</p>
<p>以下为一颗二叉查找树：</p>
<p><img src="/%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91.png" alt="/二叉查找树"></p>
</li>
</ul>
<p>&emsp;为什么一定要有这种结构呢？这种结构的好处在哪里呢？<br>接下来我们来查找一下值为10这个节点的数据，看一下具体的步骤是怎样的：</p>
<a id="more"></a>

<br>

<ol>
<li><p>查找跟节点9，如图所示：</p>
<p><img src="/%E8%8A%82%E7%82%B99.png" alt="节点9"></p>
</li>
<li><p>由于查找的节点值为10,10大于根节点9，那么久表示需要查询右边孩子节点13，如图：</p>
<p><img src="/%E8%8A%82%E7%82%B913.png" alt="节点13"></p>
</li>
<li><p>由于查询的值10 &lt; 13，那么久查询左孩子节点11：如图：</p>
<p><img src="/%E8%8A%82%E7%82%B911.png" alt="节点11"></p>
</li>
<li><p>由于查询的值10 &lt; 11,那么查询左节点10，最终查询到10这个节点值，如图：</p>
<p><img src="/%E8%8A%82%E7%82%B910.png" alt="节点10"></p>
</li>
</ol>
<p>经历了以上4步操作，最终查找到了节点数据为10的子节点。<br>以上的操作，是参照了二分查找的思想</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>红黑树-算法</tag>
      </tags>
  </entry>
</search>
